---
title: C++ Primer Plus 第四章阅读笔记 - 复合类型
---

# 数组

数组是一种数据格式，能够存储多个**同类型**的数值。

声明数组的通用格式：

```c++
typeName arrayName[arraySize];
```

## 初始化数组元素

我们可以使用大括号初始化方法**在声明时**（且**仅**在声明时）将数组初始化。

```c++
int scores[5] = {1, 2, 3, 4, 5};
```

不能将一个数组直接赋值给另一个数组。

```c++
int scores[5] = {1, 2, 3, 4, 5};
int ranks[5] = scores;//not allowed
```

初始化时提供的**元素值的个数**可以**少于**数组的**元素数目**，此时其他元素会被设置为`0`。

```c++
int scores[5] = {0, 1};
cout << scores[2];//0
```

> 于是如果想把数组全部初始化为0，可以这么做：
>
> ```c++
> int scores[5] = {0};
> int scores[5] = {};//c++11，略掉了0
> int scores[5]{};//c++11，略掉了等号和0
> ```

初始化时不提供`[]`内的值，那么C++编译器将自动计算元素个数。

值得一提的是，使用列表初始化时，不允许**缩窄转换**（备忘：硬赋“吃不下”的值）。

## 针对数组的`sizeof`

`sizeof`作用于**数组名**，得到的是整个数组的字节数；作用于数组中的某个元素，则是单个该元素占用的字节数。

```c++
int scores[5] = {1, 2, 3, 4, 5};
cout << sizeof scores << endl;//20 p.s. 4 * 5 = 20
cout << sizeof scores[2] << endl;//4
```

# 字符串

> 此处先介绍C风格字符串（char数组），下一小节介绍`string`类

`char`数组不一定是字符串，因为字符串要求以`\0`结尾。如果一个`char`数组并未以`\0`结尾，那么不应视为字符串处理，更不应使用相关函数对其进行处理，否则这些函数会一直顺着内存读下去，直至遇到`\0`。

```c++
char c1[] = {'h', 'i'};//Not a string
char c2[] = {'h', 'i', '\0'};//Right
```

## 初始化字符串

我们可以使用**字符串常量**对`char`数组进行初始化

```c++
char c1[] = "Aoligei!";
```

用**双引号**扩起的字符串**隐式地包括结尾的空字符**，譬如：

```c++
char c1[8] = "Bozo";
// B o z o \0(这个是自动加到字符串末尾的，后续其他的也会设置为\0) \0 \0 \0
```

::: danger 区分字符常量和字符串常量

字符常量用**单引号**包裹，**本质是**字符串**编码**的简略表示。在ASCII系统中，`'s' == 83`，`'s'`只是`83`的另外一个写法罢了。

字符串常量用**双引号**包裹，如`"s"`，其代表由`'s'`、`'\0'`组成的字符串。C++中视为字符串**所在的内存地址**。

:::

## 字符串常量拼接

任何两个被空白（空格、制表符、换行符）分割开来的字符串会被自动拼接成一个。

```c++
char c1[] = "Aoligei!"
            "Split!";
cout << c1;//Aoligei!Split!
```

## `strlen`的使用

要想使用`strlen`，需要包含`cstring`头文件。

`strlen`只计算可见字符，且不把空字符`\0`计算在内。

## 读取字符串

我们可以使用`cin`来读取字符串。

```c++
char c1[20] = {};
char c2[20] = {};
cin >> c1;
cin >> c2;
```

请注意：如果在读取`c1`的时候，输入了`Ao ligei`并按下回车，那么会赋给`c1`为`Ao`，且赋给`c2`为`ligei`。这和`cin`的实现有关系。其以**空白（空格、制表符和换行符）来确定字符串的结束位置**，因而会把`Ao`赋给`c1`，此时缓冲区里还有`ligei\n`，于是接下来的`cin`便直接将`ligei`赋给了`c2`。

## `cin.getline()`和`cin.get()`

这两个函数和普通的`cin`区别在于：`getline`和`get`**仅以换行符作为字符串结束的标志**，亦即一次可以读取一行，而不管中间有没有空格。

用法：`cin.getline(name, ArSize)`，`cin.get(name, ArSize)`

`getline`和`get`的区别在于：`getline`会把缓冲区中的`\n`读取并丢弃掉，而`get`并不会。所以当使用`get`来读取一行的内容时，通常还需要再调用（什么也没有的参数）`get`手动读取掉（下一个字符）`\n`，如：

```c++
char c1[20];
cin.get(c1, 10).get();
```

`cin.get(c1, 10)`返回一个`cin`对象，所以后边还能再跟一个`.get()`。

`cin.get(name, ArSize)`的一个好处在于：可以知道停止读取的原因（是读够了，还是遇到`\n`了？）。只需读完后再调用`cin.get()`获取下一个字符，查看是不是`\n`即可。

## 读取空行

使用`cin.getline()`或者`cin.get()`读取到空行时，会设置一个失效位，阻塞下面所有的`cin`相关输入，此时需要用`cin.clear()`来重置失效位。

