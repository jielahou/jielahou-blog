---
title: C++ Primer Plus 第三章阅读笔记 - 简单变量


---

> 面向对象编程（OOP）的本质是**设计并拓展自己的数据类型**。设计自己的数据类型就是**让类型与数据匹配**。

# 简单变量

为了把数据存储到计算机中，需要记录3个属性——**在哪里？啥类型？是什么？**

## 变量名

变量名需遵循一定的规则，个人感觉下面这两条很新鲜：

- 以**两个下划线**开头或者**一个下划线+一个大写字母**开头的名称被保留给实现（编译器及其使用的资源）使用
- 以**一个下划线**开头的名称被保留给实现，用作**全局标识符**。

## 整型

C++中有5种整型变量：`char`、`short`、`int`、`long`、`long long`（C++11新增），每种均有有符号和无符号版本。

## short、int、long和long long

### 宽度

4种类型的宽度在不同的计算机上可能不一样，但遵循如下的规则：

- `short`至少为16位
- `int`至少和`short`一样
- `long`至少为32位，且至少和`int`一样
- `long long`至少为64位，且至少和`long`一样

### `sizeof`和`climits`

我们可以使用`sizeof`运算符查看各类型在具体机器上的长度，使用`climits`头文件查看各类型可表示数值的范围（最大值、最小值）。

`sizeof`可以作用于类型，也可以作用于变量名。**作用于类型时，必须要加括号；作用于变量名时，可以不加括号。**

```c++
int x;
cout << "Size of int:" << sizeof x << endl;//valid，不用加括号
cout << "Size of int:" << sizeof(int) << endl;//valid，必须加括号
```

### 变量的初始化

#### 常规初始化

虽然可以先声明再赋值，但是如果知道变量的值是什么，应当**在声明时立即对其进行初始化**。

```c++
int uncles = 5;
int aunts = uncles;
int chairs = uncles + aunts;
```

#### 大括号初始化器

我们还可以使用**大括号初始化器**对**数组和结构**进行初始化。C++98允许我们用其对**单值变量**进行初始化。

```c++
int hamburgers = {24};
```

在C++11中，甚至可以略掉等号和其中的数字。（如果略掉其中的数字，则被初始化为0）

```c++
int emus{};
int emus = {};
int emus{7};
int emus = {7};
```

> 以前，初始化类变量的方式不同于初始化常规结构的方式、初始化常规结构的方式不同于初始化简单变量的方式。但大括号初始化器是一种**通用**的初始化语法，使得初始化常规变量的方式和类变量的方式更像。

## 无符号类型

`unsigned`实际上是`unsigned int`的缩写。

## 选择整数类型

- 不知道该选啥就选`int`
- 不可能为负就上`unsigned`
- 如果大于32位，则选`long`（虽然某些机器上的`int`也是32位，但是不排除其他机器上的`int`是16位，如果此时仍然是`int`会出问题，用`long`不会出现这个问题。）
- 大型整型数组可以用`short`以节省内存空间



## 整型字面值

**整型字面值**是显式地书写的常量。 

C++中使用前1~2位标识常量的基数。

- 十进制：第一位是1~9
- 八进制：第一位是0，第二位是1~7
- 十六进制：开头是`0x`或者`0X`

在C语言中，通过控制`printf`的格式串，我们可以指定是以十进制、八进制还是十六进制 显示整数。在C++中，我们可以使用控制符`dec`、`oct`、`hex`来指示`cout`以什么格式显式整数。

```c++
int x = 42;
int y = 042;
int z = 0x42;
cout << dec << x << endl;//42
cout << oct << y << endl;//42
cout << hex << z << endl;//42
```

## C++如何确定常量的类型

```c++
cout << "Year:" << 1949 << endl;
```

上面代码片段中`1949`这个常量，会被存储为什么类型呢？

C++会将**整型常量存储为`int`类型**，除非是有**特殊后缀**、**值太大不能存为`int`**。

### 特殊后缀

后缀是放在数字常量后面的字母，用于表示类型。

- `u`或`U`表示无符号常量
- `l`或`L`表示`long`型常量
- `ll`或`LL`表示`long long`型常量
- `ull`、`uLL`、`Ull`、`ULL`表示`unsigned long long`型常量

### 范围限定

对于十进制数字，会根据其范围选择是`int`、`long`还是`long long`

对于八进制或者十六进制数字，会根据其范围选择是`int`、`unsigned int`、`long`、`unsigned long`、`long long`、`unsigned long long`。

## char类型

`char`类型实际上是另一种整型。C++中也有宽字符类型（譬如`wchar_t`）可以存储更多的值。

C++中的字符字面值是使用`'`单引号包裹的，如`char x = 'x';`。

`cout`输出`char`类型变量时，输出的是对应的字符；输出与`char`类型值一样的`int`类型变量时，输出的是数字。

```c++
char x = 'x';
int y = x;
cout << x << endl;//x
cout << y << endl;//120
```

`cin`读取输入流中的数字，如果赋给`char`类型，是将该数字对应的编码赋过去；如果赋给`int`类型，则是将数字直接赋过去。

### `cout.put()`

以前在C++的早期版本中，字符类型的常量被存储为`int`类型，故`cout << 'x';`输出的会是数字，需借助`cout.put()`函数来输出字符类型的常量。现在是没有必要了。

### 转义序列

转义序列允许我们表达无法用键盘输入的字符，如`\n`、`\b`（退格）等。

这些字符也是有其自己的编码的，故可以使用其八进制或十六进制编码来表示。比如`Ctrl + Z`在ASCII中的编码是`0x1a`，于是可用如下的转义序列表示：`\032`、`\x1a`。

> 能使用符号转义序列，就不要使用其数字编码。因为不同机器不同编码对于同一个符号的编号可能不同，但符号转义序列是唯一的，会随着平台不同自动翻译。

### 通用字符名

通用字符名可以表示`ISO10646`中的码点，以`\u`或`\U`开头，`\u`后面跟4个16进制位，`\U`后面跟8个16进制位。

`\u798F`是`福`字的Unicode码点，其代表`福`字。不同机器上实际使用的编码可能会不同，故最终编译出来存储到程序中的编码可能会不同于其Unicode码点，但都是表示`福`字的码点。

之所以叫“通用字符名”，我们可以借助`ISO10646`来表示其中的任何一个字符，实际上最终的内部编码会是啥，由目标机器上的编译器做决定。

### signed char和unsigned char

`char`默认**既不是**有符号，**也不是**无符号，需要自己显式地指定。

### wchar_t

我们可以用`wchar_t`（宽字符类型）来表示扩展字符集，其长度和符号属性取决于实现。

普普通通的`cin`和`cout`只能处理`char`流，好在`iostream`头文件提供了`wcin`、`wcout`来处理`wchar_t`流。

### char16_t和char32_t

单有`wchar_t`已经不能满足需求，因为其具体长度会随实现不同而改变。C++11中新增了`char16_t`和`char32_t`。

`char16_t`是16位无符号的，符号**常量**和字符串**常量**加前缀`u`便可表示其为`char16_t`类型的常量。

`char32_t`是16位无符号的，符号**常量**和字符串**常量**加前缀`U`便可表示其为`char32_t`类型的常量。

### bool类型

`bool is_ready = true/false;`

## const限定符

在C++中，有比`#define`更好的表示常量的方法，那就是`const`限定符。

```c++
const int x = 1;
x++;//error
```

使用`const`而不是`#define`的好处如下：

- `const`可以明确指明类型
- 可以根据作用域规则将定义限制于特定的函数/文件中，而不是全局

# 浮点数

## 书写浮点数

- 标准小数表示法，如`5.20`
- E表示法，如`9.11e-39`

## 浮点类型

浮点有`float`、`double`、`long double`三种类型。

> 使用`cout.setf()`可以设置输出格式。
>
> 如`cout.setf(ios_base::fixed, ios_base::floatfield)`

## 浮点常量

浮点常量默认是`double`类型，如果期望有所更改，则可以添加后缀：

希望常量是`float`类型，可以添加`f`或`F`后缀；

希望常量是`long double`类型，可以添加`l`或`L`后缀。

```c++
cout << sizeof(1.0f) << endl;//4
cout << sizeof(1.0) << endl;//8
cout << sizeof(1.0L) << endl;//16
```

## 浮点数的优缺点

优点：表示范围很大

缺点：运算慢、精度低

# C++算术运算符

C++的算术运算符有：`+`、`-`、`*`、`/`、`%`。

对于求余，如果有一个操作数是负的，`a%b`的结果遵循下式`(a/b)*b + a%b = a`。（如：`8%-3`的结果遵循`(8/-3)*(-3) + a%b = 8`，如此便得`a%b = 2`）

## 运算符优先级和结合性

先看优先级，再看结合性。

所谓结合性，处理的是当两个符号**优先级相同**，且**作用于同一个操作数**时，这个操作数首先会被谁作用的问题。如`120 / 4 * 5 `，这个`4`先跟谁算呢？是先算`120 / 4`（得到`30`，然后`30 * 5`，得到结果`150`），还是先算`4 * 5`呢（得到`20`，然后`120 / 20`，得到结果`6`）？

由于乘除都是“从左到右结合”的，所以先算`120 / 4`，再算`30 * 5`。

## 除法分支

对不同类型的数字进行运算时，会转换成同一类型的进行计算。

```c++
cout.setf(ios_base::fixed, ios_base::floatfield);
cout << 1e7 / 9.0 << endl;//1111111.111111
cout << 1e7f / 9.0f <<endl;//1111111.125000
```

上例中，由于第二行均为`double`类型，第三行均为`float`类型，故第二行结果也是`double`的，精度更高；第三行结果是`float`的，精度稍次。

## 类型转换

下面主要介绍三种情况下涉及到的自动的类型转换

- 将一种算术类型的值赋给另一种算术类型的变量（初始化）
- 表达式中包含不同的类型
- 参数传递给函数

### 初始化和赋值进行的转换

如果将一种类型的值赋给另一种类型的变量，那么**值将会转换成接受变量的类型**。

转换时可能有精度、溢出的问题。

将**浮点型转换为整型**时，C++采取**截取**（丢掉小数部分）而不是四舍五入。

```c++
int x = 4.9;//Warning
cout << x << endl;//4
```

使用**大括号**进行初始化时，其**不允许缩窄**，即不允许被赋值的变量表示不了赋予的值。譬如整型不能表示浮点型、`char`只能表示`-128~127`间的数字等。

```c++
char x = {999};//Constant expression evaluates to 999 which cannot be narrowed to type 'char'
int y = {8.9};//Type 'double' cannot be narrowed to 'int' in initializer list
```

用大括号进行初始化时，还不能包含变量，因为编译器无法预知变量的值是否满足缩窄。

```c++
int x = 99;
char y = {x};//Non-constant-expression cannot be narrowed from type 'int' to 'char' in initializer list
```

### 表达式中的转换

表达式中的转换又分为两种，一种是一出现就会被转换的，另一种是和其他类型同时出现时才转换。

#### 一出现就被转换（整型提升）

C++在计算表达式时，将`bool`、`char`、`unsigned char`、`signed char`、`short`值转换为`int`。

除此，如果`short`比`int`短，那么`unsigned short`转换为`int`；如果`short`和`int`一样长，那么`unsigned short`转换为`unsigned int`。

`wchar_t`也会被转换为第一个能够满足需求的类型：`int`、`unsigned int`、`long`、`unsigned long`。

### 不同类型算术运算的转换

较小的类型会转换为较大的类型。如`int`和`float`相加，`int`会被转换成`float`。

### 传递参数时的转换

由函数原型控制。不控制的，`char`和`short`做整型提升，`float`提成`double`。

### 强制类型转换

强制类型转换的格式如下：

```c++
(int) x;//(typeName) value
int (x);//typeName (value)
```

除此，还有4个强制类型转换运算符，`static_cast<>`就是其中之一。`static_cast<>`相较于传统强转，其实是更严格的。

```c++
short x = 5;
cout << static_cast<int>(x)<< endl;
```

### `auto`声明

如果使用关键字`auto`声明变量，那么编译器会把变量的**类型**设置成**与初始值相同**。

`auto`在处理复杂类型时，优势方才显现。

