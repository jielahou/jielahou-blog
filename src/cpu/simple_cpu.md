---
title: 简单流水线CPU设计
---

> 本文实际上是对《CPU设计实战》（汪文祥 邢金璋 著）一书第四章的简单总结、概括。

# 设计一个简单的单周期CPU

> CPU设计的一般方法：数据通路+控制逻辑

## 准备工作

### 如何划分模块

- 某层次设计细节很多，很难画出来，把他干成一个框，作为一个模块
- 模块的接口不应该有太多
- 可以被多次使用的，比如译码器、多路选择器、寄存器堆、RAM、FIFO（First In First Out）
- 两个模块间数据总体应该呈单向流动，至多一去一回。

### PC

PC的输入有两个：一个是复位值`0xBFC00000`，一个是复位撤销后每执行一条指令，当前`PC+4`的结果。

### 虚实地址转换

在实现TLB和MMU之前，我们采用**固定映射**的地址映射机制。

`kseg0`（`0x80000000`~`0x9FFFFFFF`）映射到物理地址最低512M（`0x00000000`~`0x1FFFFFFF`）；

`kseg1`（`0xA0000000`~`0xBFFFFFFF`）也映射到物理地址最低512M（`0x00000000`~`0x1FFFFFFF`）；

其余三个段（`kuseg`、`kseg2`、`kseg3`）虚地址等于物理地址。

### 指令RAM

由于欲实现的CPU指令宽度为32比特，所以RAM的宽度至少为32比特。但RAM还是按照字节寻址的，所以我们要将取指地址除4后取整的结果作为RAM的地址输入。

## 数据通路设计

### ADDU指令

通用寄存器堆的读端口1和读端口2分别和`rs`、`rt`相连；

要实现加法，需要一个加法器。加法器两个输入`src1`、`src2`分别来自通用寄存器堆的`rdata1`、`rdata2`，输出`result`连接通用寄存器堆的`wdata`。

### ADDIU指令

> ADDIU和ADDU指令很像，如何兼顾差异性，又能最大限度复用呢？

从差异性入手，ADDIU和ADDU指令区别于ADDIU第二个操作数来自于指令的`15..0`位符号拓展至32位后形成的数据。所以在加法器`src2`输入端口前面加一个**二选一**部件。`in0`来自于通用寄存器堆的`rdata2`，`in1`来自指令的`15..0`位符号拓展至32位后形成的数据。控制信号的生成（包括接下来若干条指令的控制信号）统一放到最后说。

另一个区别，ADDU写入第`rd`号寄存器，ADDIU写入第`rt`号寄存器。在通用寄存器堆前面也加一个二选一部件，`in0`来自`rd`，`in1`来自`rt`。

### SUBU指令

复用加法器来实现减法，处理方法如下：
$$
[A]_{原码31..0}-[B]_{原码31..0}=[A]_{原码31..0}+(\textasciitilde[B]_{原码31..0})+1
$$
其中`~`是按位取反，上式中即为对`[B]原码`的32位取反。

于是需要在加法器的`src2`前面再加一个二选一部件：处理加法时不取反，直接进来；处理减法时先取反，再进来。

后面还有一个`+`，可以通过**操作加法器进位输入**实现。处理加法进位输入是0，操作减法进位输入是1。

### LW指令

#### 访存地址生成

要求是将`rs`和指令中的立即数相加，和`ADDIU`一致。

#### 从数据RAM中读数据

根据指令系统规范文档中对`LW`指令的描述，`LW`一次性要读4个字节写入第`rt`号寄存器。所以数据RAM宽度也应该是32位，因此`LW`指令的访存地址应该是4的倍数。

#### 寄存器写回结果选择

之前我们只有`ADDU`、`ADDIU`两条指令写寄存器，那俩都是将加法器的结果接到通用寄存器堆的`wdata`上，写入寄存器。现在又多一个`LW`，那只能在寄存器堆`wdata`前面再加一个二选一部件。

### SW指令

`SW`指令将`rt`寄存器的内容写入数据RAM，因此我们将通用寄存器堆的`rdata2`和数据RAM的`wdata`相连，将数据RAM的写使能作为控制信号。

### BEQ和BNE指令

#### 判断分支条件

要比较两个寄存器中的数字，一种方法是复用加法器，做减法，看结果；另一种方法是设置**独立的分支判断逻辑**。

#### 计算跳转目标

MIPS中有“延迟槽”的概念，由于判断分支条件会浪费一些时间，于是便可以把**不管是不是跳转一定要执行的指令**放在**条件分支指令**（注意是条件分支）的后面，在判断分支条件时并行执行，提高效率。

这意味着如果有一个PC为A的指令，使用分支跳转指令如果成功跳到B的话，其执行轨迹实际上是A、A+4、B。所以**执行分支指令后面的延迟槽指令时**才是**真正调整PC的时机**。

故`BEQ`和`BNE`计算跳转目标时是**基于延迟槽指令的PC**再加上(`offset`左移两位的结果)得到的。

#### PC更新

由于是在下一条延迟槽指令进行PC更新，所以我们需要将加法器（毕竟复用了`ADDIU`的数据通路么）的输出放入一个触发器中。

既然引入了分支跳转指令，`nextPC`的来源不只是当前指令PC+4了。我们要给`nextPC`加一个二选一部件，`in0`来自PC+4，另一个输入`in1`来自触发器。

什么时候选择触发器中的数据呢？条件有二：一是当前**正在执行延迟槽中的指令**，二是`BEQ`、`BNE`**要求跳转**。

### JAL指令





