<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://mister-hope.github.io/system/task_management.html"><meta property="og:site_name" content="Jielahou's Blog"><meta property="og:title" content="任务管理"><meta property="og:description" content="任务管理 任务管理概述 什么是任务？ 任务是处理器可以调度、执行和挂起的工作单元。它可以用于执行程序、任务或进程、操作系统服务实用程序、中断或异常处理程序、内核或执行实用程序。 IA-32体系结构提供了一种保存任务状态、调度任务以供执行以及从一个任务切换到另一个任务的机制。在保护模式下操作时，所有处理器的执行都在任务中进行。即使是简单的系统也必须定义至少一个任务。更复杂的系统可以使用处理器的任务管理机制来支持多任务应用程序。"><meta property="og:type" content="article"><meta property="og:image" content="https://mister-hope.github.io/"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-05-16T02:21:26.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="任务管理"><meta property="article:modified_time" content="2023-05-16T02:21:26.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"任务管理","image":["https://mister-hope.github.io/"],"dateModified":"2023-05-16T02:21:26.000Z","author":[]}</script><title>任务管理 | Jielahou's Blog</title><meta name="description" content="任务管理 任务管理概述 什么是任务？ 任务是处理器可以调度、执行和挂起的工作单元。它可以用于执行程序、任务或进程、操作系统服务实用程序、中断或异常处理程序、内核或执行实用程序。 IA-32体系结构提供了一种保存任务状态、调度任务以供执行以及从一个任务切换到另一个任务的机制。在保护模式下操作时，所有处理器的执行都在任务中进行。即使是简单的系统也必须定义至少一个任务。更复杂的系统可以使用处理器的任务管理机制来支持多任务应用程序。">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-86d03c91.css" as="style"><link rel="stylesheet" href="/assets/style-86d03c91.css">
    <link rel="modulepreload" href="/assets/app-6b90294d.js"><link rel="modulepreload" href="/assets/framework-3be2c3ae.js"><link rel="modulepreload" href="/assets/task_management.html-22c26002.js"><link rel="modulepreload" href="/assets/task_management.html-df14423a.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container no-sidebar has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><!----><!----><span class="site-name">Jielahou&#39;s Blog</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="主页"><span class="font-icon icon iconfont icon-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/intro.html" class="nav-link" aria-label="关于"><span class="font-icon icon iconfont icon-info" style=""></span>关于<!----></a></div><div class="nav-item hide-in-mobile"><a href="/link.html" class="nav-link" aria-label="友链"><span class="font-icon icon iconfont icon-link" style=""></span>友链<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/jielahou/jielahou-blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->任务管理</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://jielahou.com" target="_blank" rel="noopener noreferrer">jielahou</a></span><span property="author" content="jielahou"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-05-16T02:21:26.000Z"></span><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 24 分钟</span><meta property="timeRequired" content="PT24M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务管理概述" class="router-link-active router-link-exact-active toc-link level2">任务管理概述</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务的结构" class="router-link-active router-link-exact-active toc-link level3">任务的结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务状态" class="router-link-active router-link-exact-active toc-link level3">任务状态</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务的执行" class="router-link-active router-link-exact-active toc-link level3">任务的执行</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务的数据结构" class="router-link-active router-link-exact-active toc-link level2">任务的数据结构</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务状态段-task-state-segment-tss" class="router-link-active router-link-exact-active toc-link level3">任务状态段 Task-State Segment (TSS)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#tss-描述符" class="router-link-active router-link-exact-active toc-link level3">TSS 描述符</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务寄存器" class="router-link-active router-link-exact-active toc-link level3">任务寄存器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务门描述符-task-gate-descriptor" class="router-link-active router-link-exact-active toc-link level3">任务门描述符 Task-Gate Descriptor</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务切换" class="router-link-active router-link-exact-active toc-link level2">任务切换</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#什么时候发生任务切换" class="router-link-active router-link-exact-active toc-link level3">什么时候发生任务切换？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#发生任务切换时-处理器会执行哪些操作" class="router-link-active router-link-exact-active toc-link level3">发生任务切换时，处理器会执行哪些操作？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#中断或异常向量指向-idt-表中的中断门或陷阱门-会发生任务切换吗" class="router-link-active router-link-exact-active toc-link level3">中断或异常向量指向 IDT 表中的中断门或陷阱门，会发生任务切换吗？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务链" class="router-link-active router-link-exact-active toc-link level2">任务链</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#如何判断任务是否嵌套" class="router-link-active router-link-exact-active toc-link level3">如何判断任务是否嵌套？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#什么情况会发生任务嵌套" class="router-link-active router-link-exact-active toc-link level3">什么情况会发生任务嵌套？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务嵌套时修改了哪些标志位" class="router-link-active router-link-exact-active toc-link level3">任务嵌套时修改了哪些标志位？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务嵌套时-如何返回前一任务" class="router-link-active router-link-exact-active toc-link level3">任务嵌套时，如何返回前一任务？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务地址空间" class="router-link-active router-link-exact-active toc-link level2">任务地址空间</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#什么是任务地址空间" class="router-link-active router-link-exact-active toc-link level3">什么是任务地址空间？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#任务地址空间包括什么" class="router-link-active router-link-exact-active toc-link level3">任务地址空间包括什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#了解把任务映射到线性和物理地址空间的方法" class="router-link-active router-link-exact-active toc-link level3">了解把任务映射到线性和物理地址空间的方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/task_management.html#了解任务逻辑地址空间-及如何在任务之间共享数据的方法" class="router-link-active router-link-exact-active toc-link level3">了解任务逻辑地址空间，及如何在任务之间共享数据的方法？</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="任务管理" tabindex="-1"><a class="header-anchor" href="#任务管理" aria-hidden="true">#</a> 任务管理</h1><h2 id="任务管理概述" tabindex="-1"><a class="header-anchor" href="#任务管理概述" aria-hidden="true">#</a> 任务管理概述</h2><h4 id="什么是任务" tabindex="-1"><a class="header-anchor" href="#什么是任务" aria-hidden="true">#</a> 什么是任务？</h4><p><strong>任务</strong>是处理器可以调度、执行和挂起的<strong>工作单元</strong>。它可以<strong>用于</strong>执行程序、任务或进程、操作系统服务实用程序、中断或异常处理程序、内核或执行实用程序。</p><p>IA-32体系结构提供了一种保存任务状态、调度任务以供执行以及从一个任务切换到另一个任务的机制。在<strong>保护模式下</strong>操作时，<strong>所有处理器的执行都在任务中进行</strong>。即使是简单的系统也必须定义至少一个任务。更复杂的系统可以使用处理器的任务管理机制来支持多任务应用程序。</p><h4 id="_80x86-提供了哪些硬件支持" tabindex="-1"><a class="header-anchor" href="#_80x86-提供了哪些硬件支持" aria-hidden="true">#</a> <code>80x86</code> 提供了哪些硬件支持？</h4><ul><li>任务状态段(TSS)</li><li>TSS描述符</li><li>任务寄存器(TR)</li><li>任务门</li><li>任务链</li><li>...</li></ul><h4 id="描述符表中与任务相关的描述符有哪些" tabindex="-1"><a class="header-anchor" href="#描述符表中与任务相关的描述符有哪些" aria-hidden="true">#</a> 描述符表中与任务相关的描述符有哪些？</h4><ul><li>TSS段描述符</li><li>任务门描述符</li><li>...</li></ul><h4 id="任务切换与过程调用的区别是什么" tabindex="-1"><a class="header-anchor" href="#任务切换与过程调用的区别是什么" aria-hidden="true">#</a> 任务切换与过程调用的区别是什么？</h4><blockquote><p>注：本小节内容源自ChatGPT，仅供参考</p></blockquote><p>任务切换与过程调用有以下几点区别：</p><ol><li><p>目的不同。任务切换是为了让多个任务在同一时间内共享处理器资源，从而提高处理效率；而过程调用是在同一任务中的不同函数间进行调用，目的是为了完成特定的功能。</p></li><li><p>触发条件不同。任务切换是由操作系统内核进行调度和切换的，触发条件一般是当前任务的时间片用完或者发生了某些中断事件；而过程调用是由程序员在代码中主动进行的，通过指令调用实现。</p></li><li><p>上下文切换不同。任务切换涉及到需要保存和恢复任务的上下文信息，包括处理器寄存器、程序计数器、堆栈等；而过程调用只需要保存和恢复当前函数的信息，一般只需要保存和恢复寄存器和堆栈中的关键信息。</p></li><li><p>处理器状态不同。任务切换时需要切换处理器的运行状态和特权级，而过程调用时保持当前运行状态和特权级不变。</p></li></ol><p>总之，任务切换和过程调用是两种不同的操作，目的和实现方式都有所不同。在操作系统内核的实现和程序开发中，需要根据具体的场景选择合适的方式。</p><h3 id="任务的结构" tabindex="-1"><a class="header-anchor" href="#任务的结构" aria-hidden="true">#</a> 任务的结构</h3><ul><li>一个任务由几部分构成？</li></ul><p>任务由两部分组成：<strong>任务执行空间</strong>和<strong>任务状态段（TSS）</strong>。</p><p><strong>TSS指定组成任务执行空间的段</strong>，并为<strong>任务状态信息</strong>提供存储位置。在多任务系统中，TSS还提供了一种用于链接任务(<code>linking tasks</code>)的机制。</p><p>任务由其TSS的段选择子标识。当任务被加载到处理器中执行时，TSS的段选择子、基地址、段界限和段描述符属性被加载到任务寄存器中。</p><p>如果对任务执行<strong>分页</strong>，则将任务使用的<strong>页目录的基地址</strong>加载到**控制寄存器<code>CR3</code>**中。</p><figure><img src="/assets/structure_of_a_task-18c3170e.png" alt="structure_of_a_task" tabindex="0"><figcaption>structure_of_a_task</figcaption></figure><ul><li>任务执行空间包括什么？</li></ul><p><strong>任务执行空间</strong>由一个<strong>代码段</strong>、一个<strong>堆栈段</strong>和一个或多个<strong>数据段</strong>组成（见下图）。</p><ul><li>为什么会有多个特权级栈空间？</li></ul><p>如果操作系统或执行程序使用处理器的特权级别<strong>保护</strong>机制，则任务执行空间还为<strong>每个</strong>特权级别<strong>提供单独的堆栈</strong>。</p><h3 id="任务状态" tabindex="-1"><a class="header-anchor" href="#任务状态" aria-hidden="true">#</a> 任务状态</h3><h4 id="当前正在执行的任务状态包括哪些内容" tabindex="-1"><a class="header-anchor" href="#当前正在执行的任务状态包括哪些内容" aria-hidden="true">#</a> 当前正在执行的任务状态包括哪些内容？</h4><p>以下项目定义了当前正在执行的任务的状态：</p><ul><li>任务的当前执行空间，由段寄存器（<code>CS</code>、<code>DS</code>、<code>SS</code>、<code>ES</code>、<code>FS</code>和<code>GS</code>）中的段选择子定义；</li><li>通用寄存器的状态；</li><li><code>EFLAGS</code>寄存器的状态；</li><li><code>EIP</code>寄存器的状态；</li><li>控制寄存器<code>CR3</code>的状态；</li><li>任务寄存器的状态；</li><li>LDTR寄存器的状态；</li><li>I/O映射基地址和I/O映射（包含在TSS中）；</li><li>指向特权0、1和2堆栈（包含在TSS中）的堆栈指针；</li><li>链接到以前执行的任务（包含在TSS中）；</li></ul><p>在调度任务之前，除任务寄存器的状态外，所有这些项都包含在任务的TSS中；此外，LDTR寄存器的完整内容不包含在TSS中，只包含在LDT的段选择器中。</p><h4 id="掌握每一个被包含内容的含义" tabindex="-1"><a class="header-anchor" href="#掌握每一个被包含内容的含义" aria-hidden="true">#</a> 掌握每一个被包含内容的含义？</h4><p>各个寄存器的含义已在前三次读书笔记中整理，此处不再赘述: )</p><h4 id="为什么要包含这些内容" tabindex="-1"><a class="header-anchor" href="#为什么要包含这些内容" aria-hidden="true">#</a> 为什么要包含这些内容？</h4><p>为了在任务“回来”时，能够恢复到任务被打断的时的状态。</p><h3 id="任务的执行" tabindex="-1"><a class="header-anchor" href="#任务的执行" aria-hidden="true">#</a> 任务的执行</h3><h4 id="任务的执行方式有几种" tabindex="-1"><a class="header-anchor" href="#任务的执行方式有几种" aria-hidden="true">#</a> 任务的执行方式有几种？</h4><p>软件或处理器可以通过以下方式之一调度任务以供执行：</p><p>(1) 使用<code>CALL</code>指令对任务的显式调用；</p><p>(2) 使用<code>JMP</code>指令显式跳转到任务；</p><p>(3) （处理器）对中断处理程序任务的隐式调用；</p><p>(4) 对异常处理程序任务的隐式调用；</p><p>(5) 当<code>EFLAGS</code>寄存器中的NT标志被置1时的返回（由<code>IRET</code>指令启动）。</p><p>所有这些用于调度任务的方法都<strong>使用</strong>指向任务门或任务TSS的<strong>段选择子</strong>来<strong>标识要调度的任务</strong>。当<strong>使用<code>CALL</code>或<code>JMP</code>指令调度任务时</strong>，指令中的<strong>选择子可以直接选择TSS</strong>，<strong>也可以选择</strong>用于保存TSS选择器的<strong>任务门</strong>。当<strong>调度任务以处理中断或异常时</strong>，中断或异常的IDT条目必须包含一个任务门，该任务门包含中断或异常处理程序TSS的选择子。</p><p>当<strong>任务被调度</strong>执行时，在当前运行的任务和调度的任务之间会发生<strong>任务切换</strong>。在任务切换期间，当前正在执行的任务的执行环境（称为任务的状态或<strong>上下文</strong>）<strong>保存在其TSS中</strong>，并<strong>暂停任务的执行</strong>。然后将调度任务的上下文加载到处理器中，并从新加载的EIP寄存器指向的指令开始执行该任务。如果自上次初始化系统以来，任务尚未运行，则<code>EIP</code>将指向任务代码的第一条指令；否则，它将指向任务上次活动时执行的最后一条指令之后的下一条指令。</p><blockquote><p>备注：在“中断和异常处理”部分，当时是说如果特权级和中断程序一致，不会发生任务切换。</p></blockquote><p>如果当前正在执行的任务（调用任务 the calling task）调用了被调度的任务（被调用任务 the called task），则<strong>调用任务(the calling task)的TSS段选择子存储在被调用任务(the called task)的TSS中</strong>，以提供返回调用任务(the calling task)的链接。</p><p>中断和异常可以通过任务切换到处理程序任务来处理。这里，处理器执行任务切换以处理中断或异常，并在从中断处理程序任务或异常处理程序任务返回时自动切换回被中断的任务。该机制还可以处理在中断任务期间发生的中断。</p><p>作为任务切换的一部分，处理器还可以切换到另一个LDT，允许每个任务具有不同的基于LDT的段的逻辑到物理地址映射。页面目录基寄存器（<code>CR3</code>）也在任务交换机上重新加载，允许每个任务都有自己的一组页面表。这些保护设施有助于隔离任务并防止它们相互干扰。</p><p>如果不使用保护机制，则处理器在任务之间不提供保护。即使使用多个权限级别进行保护的操作系统也是如此。如果以特权级别3运行的任务与其他特权级别3的任务使用相同的LDT和页表，该任务可能会访问代码并损坏数据和其他任务的堆栈。</p><p>使用任务管理机制来处理多任务应用程序是可选的。多任务处理可以在软件中进行，每个软件定义的任务都在单个IA-32架构的任务上下文中执行。</p><ul><li>熟悉掌握每一种执行方式的过程</li><li><code>Linux 0.00</code> 用的是哪种方式？</li></ul><h4 id="任务可以递归调用吗-为什么" tabindex="-1"><a class="header-anchor" href="#任务可以递归调用吗-为什么" aria-hidden="true">#</a> 任务可以递归调用吗？为什么？</h4><p>对于所有IA-32处理器，任务<strong>都不是递归</strong>的。任务<strong>不能调用或跳转到自身</strong>。</p><p>如果允许递归调用，则需要为每次递归调用记录信息。但是一个任务只有一个TSS，无法记录下来“每次”的信息。如果需要递归调用，可以为每个过程单独开一个TSS。</p><h2 id="任务的数据结构" tabindex="-1"><a class="header-anchor" href="#任务的数据结构" aria-hidden="true">#</a> 任务的数据结构</h2><h3 id="任务状态段-task-state-segment-tss" tabindex="-1"><a class="header-anchor" href="#任务状态段-task-state-segment-tss" aria-hidden="true">#</a> 任务状态段 Task-State Segment (TSS)</h3><p>恢复任务所需的处理器状态信息保存在称为<strong>任务状态段</strong>（TSS）的系统段中。下图显示了为32位CPU设计的任务的TSS格式。TSS的字段分为两大类：动态字段和静态字段。</p><figure><img src="/assets/32bit_tss-76048015.png" alt="32bit_tss" tabindex="0"><figcaption>32bit_tss</figcaption></figure><p>当任务<strong>在任务切换期间</strong>暂停时，处理器会<strong>更新动态字段</strong>。以下是动态字段：</p><ul><li><strong>通用寄存器字段</strong>：任务切换之前<code>EAX</code>、<code>ECX</code>、<code>EDX</code>、<code>EBX</code>、<code>ESP</code>、<code>EBP</code>、<code>ESI</code>和<code>EDI</code>寄存器的状态；</li><li><strong>段选择子字段</strong>：任务切换前存储在<code>ES</code>、<code>CS</code>、<code>SS</code>、<code>DS</code>、<code>FS</code>和<code>GS</code>寄存器中的段选择子；</li><li><strong><code>EFLAGS</code>寄存器字段</strong>：任务切换前<code>EFLAGS</code>寄存器的状态；</li><li><strong><code>EIP</code>（指令指针）字段</strong>：任务切换前EIP寄存器的状态；</li><li><strong>上一任务链接字段</strong>：包含上一任务TSS的段选择子（在由调用、中断或异常引起的任务切换时更新）。此字段（有时称为反向链接字段(back link field)）允许使用<code>IRET</code>指令将任务切换回前一任务。</li></ul><p>处理器读取<strong>静态字段</strong>，但<strong>通常不会更改它们</strong>。这些字段是在创建任务时设置的。以下是静态字段：</p><ul><li><p><strong>LDT段选择子字段</strong>：包含任务的LDT的段选择子；</p></li><li><p><strong><code>CR3</code>控制寄存器字段</strong>：包含任务要使用的<strong>页目录的基地址</strong>。控制寄存器<code>CR3</code>也被称为页目录基寄存器（PDBR）；</p></li><li><p><strong>特权级别0、1、2的堆栈指针字段</strong>：这些堆栈指针由逻辑地址组成，该逻辑地址由堆栈段（<code>SS0</code>、<code>SS1</code>和<code>SS2</code>）的段选择子和堆栈中的偏移量（<code>ESP0</code>、<code>ESP1</code>和<code>ESP2</code>）组成。请注意，对于特定任务，这些字段中的值是<strong>静态</strong>的；而如果在任务内发生<strong>堆栈切换</strong>，<strong>则<code>SS</code>和<code>ESP</code>值将改变</strong>；</p></li><li><p><strong>T（debug trap）标志</strong>（字节100，位0）：设置后，当任务<strong>切换到此任务时</strong>，T标志会导致处理器<strong>引发调试异常</strong>（请参阅第17.3.1.5节“任务切换异常条件”）。</p></li><li><p><strong>I/O映射基地址字段</strong>：(注：不知道<code>bitmap</code>在x86中的含义，这里先翻译成位图了，感觉怪怪的)包含从TSS底部到I/O权限位图和中断重定向位图的16位偏移量。当存在时，这些映射存储在TSS中较高的地址。</p><p>I/O映射基地址指向I/O许可位图的开始和中断重定向位图的结束。</p></li></ul><h3 id="tss-描述符" tabindex="-1"><a class="header-anchor" href="#tss-描述符" aria-hidden="true">#</a> <code>TSS</code> 描述符</h3><blockquote><p>TSS Descriptor, 手册P227</p></blockquote><p>与所有其他段一样，TSS 由<strong>TSS段描述符</strong>定义。 TSS 段描述符<strong>只能放在 GDT 中</strong>；它们不能放在 LDT 或 IDT 中。</p><p>尝试使用<code>TI</code>标志（指示当前 LDT）为1的段选择子访问 TSS 会导致在 <code>CALL</code> 和 <code>JMP</code> 期间生成一般保护异常（<code>#GP</code>）；若是在 <code>IRET</code> 期间会导致无效的 TSS 异常 (<code>#TS</code>)。如果尝试将 TSS 的段选择子加载到段寄存器中，也会生成一般保护异常。</p><p>类型字段中的忙标志（B）指示任务是否忙。忙任务是指当前正在运行或挂起的任务。类型字段值为 <code>1001B</code> 的表示非活动任务；值 <code>1011B</code> 表示任务繁忙。任务不是递归的。处理器使用忙标志来检测对被中断任务的调用尝试。为了确保只有一个忙标志与任务相关联，每个 TSS 应该只有一个指向它的 TSS 描述符。</p><p><code>base</code>、<code>limit</code> 和 <code>DPL</code> 字段以及 <code>granularity</code> 和 <code>present</code> 标志的功能类似于它们在数据段描述符中的使用（请参阅第 3.4.5 节，“段描述符”）。当 32 位 TSS 的 TSS 描述符中的 G 标志为 0 时，段界限的值必须等于或大于 <code>67H</code>，比 TSS 的最小大小小一个字节。尝试切换到一个对应TSS段界限小于 <code>67H</code>的任务会生成无效 TSS 异常 (<code>#TS</code>)。如果包含 I/O 权限位图或操作系统存储额外数据，则需要更大的段界限。处理器不会在任务切换时检查段界限是否大于 67H ；但是，它会在访问 I/O 权限位图或中断重定向位图时进行检查。</p><p>任何可以访问 TSS 描述符的程序或过程（即，其 <code>CPL</code> 在数值上等于或小于 TSS 描述符的 DPL）都可以通过调用或跳转来分派任务。</p><p>在大多数系统中，TSS 描述符的 DPL 被设置为小于 3 的值，因此只有特权软件才能执行任务切换。但是，在多任务应用程序中，某些 TSS 描述符的 DPL 可能会设置为 3，以允许在应用程序（或用户）特权级别进行任务切换。</p><figure><img src="/assets/tss_descriptor-1960e808.png" alt="tss_descriptor" tabindex="0"><figcaption>tss_descriptor</figcaption></figure><h3 id="任务寄存器" tabindex="-1"><a class="header-anchor" href="#任务寄存器" aria-hidden="true">#</a> 任务寄存器</h3><p><strong>任务寄存器</strong>保存<strong>当前任务</strong>的 TSS 的 <strong>16 位段选择子</strong>和<strong>整个段描述符</strong>（32 位基地址、16 位段限制和描述符属性），如下图所示。<strong>段描述符是从当前任务的 GDT 中的 TSS 描述符</strong>复制而来的。图 7-5 显示了处理器用来访问 TSS 的路径（使用任务寄存器中的信息）。</p><figure><img src="/assets/tss_reg_detail-37d085ce.png" alt="tss_reg_detail" tabindex="0"><figcaption>tss_reg_detail</figcaption></figure><p>任务寄存器有可见部分（可以通过软件读取和更改）和不可见部分（由处理器维护，软件无法访问）。可见部分的段选择子指向 GDT 中的一个 TSS 描述符。处理器使用任务寄存器的不可见部分来缓存 TSS 的段描述符。将这些值缓存在寄存器中可以提高任务的执行效率。 <code>LTR</code>（加载任务寄存器）和<code>STR</code>（存储任务寄存器）指令加载和读取任务寄存器的可见部分：</p><ul><li><code>LTR</code> 指令将指向 GDT 中的 TSS 描述符的段选择子（源操作数）加载到任务寄存器中。然后它使用来自 TSS 描述符的信息加载任务寄存器的不可见部分。 <code>LTR</code> 是一条特权指令，只有在 CPL 为 0 时才能执行。它在系统初始化期间用于将初始值放入任务寄存器中。之后，当发生任务切换时，任务寄存器的内容会被隐式更改。</li><li><code>STR</code>（存储任务寄存器）指令将任务寄存器的可见部分存储在通用寄存器或内存中。该指令可以由以任何特权级别运行的代码执行，以识别当前正在运行的任务。但是，它通常仅由操作系统软件使用。</li></ul><p>在处理器上电或复位时，段选择子和基地址被设置为默认值 0；段界限设置为 <code>FFFFH</code>。</p><p>下图显示了处理器用来访问 TSS 的过程（使用任务寄存器中的信息）：</p><figure><img src="/assets/tss_register-df5f8864.png" alt="tss_register" tabindex="0"><figcaption>tss_register</figcaption></figure><h3 id="任务门描述符-task-gate-descriptor" tabindex="-1"><a class="header-anchor" href="#任务门描述符-task-gate-descriptor" aria-hidden="true">#</a> 任务门描述符 Task-Gate Descriptor</h3><p>IDT中使用的任务门的格式与GDT或LDT中的任务门格式相同（见第7.2.5节，“任务门描述符”）。任务门包含异常和/或中断处理程序任务的TSS的段选择子。</p><p><strong>任务门描述符</strong>提供了<strong>对任务的间接、受保护的引用</strong>。它可以放置在GDT、LDT或IDT中。任务门描述符中的TSS段选择子字段指向GDT中的TSS描述符，段选择子中的<code>RPL</code>未使用。</p><p>任务门描述符的DPL控制在任务切换期间对TSS描述符的访问。当程序或过程通过任务门调用或跳转到任务时，指向任务门的门选择子的<code>CPL</code>和<code>RPL</code>字段必须小于或等于任务门描述符的<code>DPL</code>。请注意，<strong>当使用任务门时，不会使用目标 TSS 描述符的 DPL</strong>。</p><figure><img src="/assets/task_gate_descriptor-e1d21a65.png" alt="task_gate_descriptor" tabindex="0"><figcaption>task_gate_descriptor</figcaption></figure><p>可以通过任务门描述符或 TSS 描述符访问任务。这两种结构都满足以下需求：</p><ul><li><strong>一个任务只有一个忙标志</strong>：因为任务的忙标志存储在 TSS 描述符中，所以每个任务应该只有一个 TSS 描述符。但是，可能有多个任务门引用相同的 TSS 描述符。</li><li><strong>提供对任务的选择性访问</strong>：任务门满足了这种需求，因为它们可以驻留在 LDT 中并且可以具有不同于 TSS 描述符的 DPL 的 DPL。没有足够权限访问 GDT（通常 DPL 为 0）中任务的 TSS 描述符的程序或过程可能被允许通过具有更高 DPL 的任务门访问该任务。任务门为操作系统提供了更大的自由度来限制对特定任务的访问。</li><li><strong>由独立任务处理中断或异常</strong>：任务门也可能驻留在 IDT 中，它允许中断和异常由处理程序任务处理。当中断或异常向量指向任务门时，处理器切换到指定的任务。</li></ul><p>下图说明了 LDT 中的任务门、GDT 中的任务门和 IDT 中的任务门如何都指向同一个任务：</p><figure><img src="/assets/task_gates_referencing_the_same_task-64b61609.png" alt="task_gates_referencing_the_same_task" tabindex="0"><figcaption>task_gates_referencing_the_same_task</figcaption></figure><h2 id="任务切换" tabindex="-1"><a class="header-anchor" href="#任务切换" aria-hidden="true">#</a> 任务切换</h2><p>此部分内容重点掌握：</p><h3 id="什么时候发生任务切换" tabindex="-1"><a class="header-anchor" href="#什么时候发生任务切换" aria-hidden="true">#</a> 什么时候发生任务切换？</h3><p>在以下四种情况之一中，处理器将执行转移到另一个任务：</p><ul><li>当前程序、任务或过程<strong>对 GDT 中的 <em>TSS 描述符</em>执行 <code>JMP</code> 或 <code>CALL</code> 指令</strong>；</li><li>当前程序、任务或过程<strong>对 GDT 或当前 LDT 中的<em>任务门描述符</em>执行 <code>JMP</code> 或 <code>CALL</code> 指令</strong>。</li><li><strong>指向 IDT 中的任务门描述符的中断或异常向量</strong>；</li><li>当前任务在 EFLAGS 寄存器中的 <strong><code>NT</code> 标志为1时执行 <code>IRET</code></strong>。</li></ul><p><code>JMP</code>、<code>CALL</code> 和 <code>IRET</code> 指令以及中断和异常都是重定向程序的机制。 （调用或跳转到任务时）对TSS描述符或任务门的引用或（执行 IRET 指令时）<code>NT</code> 标志的状态决定是否发生任务切换。</p><h3 id="发生任务切换时-处理器会执行哪些操作" tabindex="-1"><a class="header-anchor" href="#发生任务切换时-处理器会执行哪些操作" aria-hidden="true">#</a> 发生任务切换时，处理器会执行哪些操作？</h3><p>处理器在切换到新任务时执行以下操作：</p><ol><li>从任务门或先前的任务链接字段（对于使用 <code>IRET</code> 指令启动的任务切换），<strong>获取新任务的 TSS 段选择子作为 <code>JMP</code> 或 <code>CALL</code> 指令的操作数</strong>。</li><li><strong>检查是否允许当前（旧）任务切换到新任务</strong>。数据访问权限规则适用于 <code>JMP</code> 和 <code>CALL</code> 指令。当前（旧）任务的 <strong>CPL</strong> 和新任务的段选择子的 <strong>RPL</strong> 必须<strong>小于或等于</strong>被引用的 <strong>TSS 描述符或任务门的 DPL</strong>。</li><li>检查新任务的 TSS 描述符是否为1并且具有有效段界限（大于或等于 <code>67H</code>）。</li><li><strong>检查新任务是否可用</strong>（调用、跳转、异常或中断）<strong>或忙</strong>（<code>IRET</code> 返回）。</li><li>检查任务切换中使用的当前（旧）TSS、新 TSS 和所有段描述符是否已分页到系统内存中。</li><li>如果任务切换是用 <code>JMP</code> 或 <code>IRET</code> 指令启动的，处理器会清除当前（旧）任务的 TSS 描述符中的忙（B）标志；如果使用 <code>CALL</code> 指令、异常或中断启动：busy (B) 标志保持设置(be left set，所以究竟是设置还是不设置？)。</li><li>如果任务切换是用 <code>IRET</code> 指令启动的，处理器会清除 <code>EFLAGS</code> 寄存器临时保存映像中的 <code>NT</code> 标志；如果使用 <code>CALL</code> 或 <code>JMP</code> 指令、异常或中断启动，则保存的 <code>EFLAGS</code> 映像中的 <code>NT</code> 标志将保持不变。</li><li><strong>在当前（旧）任务的 TSS 中保存当前（旧）任务的状态</strong>。处理器在任务寄存器中找到当前TSS的基地址，然后将以下寄存器的状态复制到旧任务的TSS中：所有通用寄存器，来自段寄存器的段选择器，EFLAGS寄存器的临时保存映像和指令指针寄存器 (<code>EIP</code>)。</li><li>如果任务切换是通过 <code>CALL</code> 指令、异常或中断启动的，处理器在从新任务加载的 EFLAGS 中将 <code>NT</code> 标志置1。如果用 <code>IRET</code> 指令或 <code>JMP</code> 指令启动，<code>NT</code> 标志反应(reflect)从新任务加载的 EFLAGS 中 <code>NT</code> 的状态(意思是不改变NT标志呗)。</li><li>如果任务切换是通过 <code>CALL</code> 指令、<code>JMP</code> 指令、异常或中断启动的，则处理器会在新任务的 <code>TSS</code> 描述符中设置忙 (B) 标志；如果使用 <code>IRET</code> 指令启动，则忙 (B) 标志保持设置状态(be left set)。</li><li>使用新任务的 TSS 的段选择器和描述符加载任务寄存器。</li><li>TSS 状态被加载到处理器中。这包括 <code>LDTR</code> 寄存器、<code>PDBR</code>（控制寄存器 <code>CR3</code>）、<code>EFLAGS</code> 寄存器、<code>EIP</code> 寄存器、通用寄存器和段选择器。</li><li>加载并限定(qualified)与段选择子关联的描述符。与此加载和限定(qualified)相关的任何错误都发生在新任务的上下文中，并且可能会破坏体系结构状态。</li><li>开始执行新任务。 （对于异常处理程序，新任务的第一条指令似乎尚未执行。）</li></ol><h3 id="中断或异常向量指向-idt-表中的中断门或陷阱门-会发生任务切换吗" tabindex="-1"><a class="header-anchor" href="#中断或异常向量指向-idt-表中的中断门或陷阱门-会发生任务切换吗" aria-hidden="true">#</a> 中断或异常向量指向 <code>IDT</code> 表中的中断门或陷阱门，会发生任务切换吗？</h3><p>答：理论上不会。从上面“什么时候发生任务切换”部分可知，只有对<strong>任务门</strong>的调用会发生任务切换。根据前面做的读书报告，如果是中断门或陷阱门被调用，那么可能会发生堆栈切换。</p><h2 id="任务链" tabindex="-1"><a class="header-anchor" href="#任务链" aria-hidden="true">#</a> 任务链</h2><h3 id="如何判断任务是否嵌套" tabindex="-1"><a class="header-anchor" href="#如何判断任务是否嵌套" aria-hidden="true">#</a> 如何判断任务是否嵌套？</h3><p>TSS 的前一个任务链接字段（有时称为“反向链接”）和 EFLAGS 寄存器中的 <code>NT</code> 标志用于将执行返回到前一个任务。 <code>EFLAGS.NT = 1</code> 表示当前执行的任务嵌套在另一个任务的执行中。</p><h3 id="什么情况会发生任务嵌套" tabindex="-1"><a class="header-anchor" href="#什么情况会发生任务嵌套" aria-hidden="true">#</a> 什么情况会发生任务嵌套？</h3><p>当**<code>CALL</code>指令、中断或异常导致任务切换**时：处理器将当前TSS的段选择符复制到新任务的TSS的前一个任务链接域；然后它设置 <code>EFLAGS.NT</code> = 1。</p><p>当 <strong><code>JMP</code> 指令导致任务切换时，新任务不会嵌套</strong>。未使用先前的任务链接字段且 <code>EFLAGS.NT = 0</code>。当不需要嵌套时，使用 <code>JMP</code> 指令分派新任务。</p><h3 id="任务嵌套时修改了哪些标志位" tabindex="-1"><a class="header-anchor" href="#任务嵌套时修改了哪些标志位" aria-hidden="true">#</a> 任务嵌套时修改了哪些标志位？</h3><p>修改了<code>EFLAGS</code>中的<code>NT</code>标志位。</p><h3 id="任务嵌套时-如何返回前一任务" tabindex="-1"><a class="header-anchor" href="#任务嵌套时-如何返回前一任务" aria-hidden="true">#</a> 任务嵌套时，如何返回前一任务？</h3><p>如果软件使用 <code>IRET</code> 指令暂停新任务，处理器检查 <code>EFLAGS.NT = 1</code>；然后它使用当前任务TSS中上一个任务链接字段中的值返回到上一个任务。</p><h2 id="任务地址空间" tabindex="-1"><a class="header-anchor" href="#任务地址空间" aria-hidden="true">#</a> 任务地址空间</h2><h3 id="什么是任务地址空间" tabindex="-1"><a class="header-anchor" href="#什么是任务地址空间" aria-hidden="true">#</a> 什么是任务地址空间？</h3><p><strong>任务的地址空间由任务可以访问的段组成</strong>。</p><h3 id="任务地址空间包括什么" tabindex="-1"><a class="header-anchor" href="#任务地址空间包括什么" aria-hidden="true">#</a> 任务地址空间包括什么？</h3><p>这些段包括 <strong>TSS 中引用的代码、数据、堆栈和系统段以及任务代码可以访问的任何其他段</strong>。这些段被映射到处理器的线性地址空间，而线性地址空间又被映射到处理器的物理地址空间（直接或通过分页）。</p><p>TSS 中的 <code>LDT</code> 段字段可用于为每个任务提供其自己的 <code>LDT</code>。为任务提供自己的 LDT 允许将自己的任务地址空间与其他任务隔离（通过将与任务关联的所有段的段描述符放置在自己的 LDT 中）。</p><p>多个任务也可以使用相同的 LDT。这是一种内存高效的方式，允许特定任务相互通信或控制，而不会降低整个系统的保护屏障。</p><p>因为所有任务都可以访问 GDT，所以也可以通过GDT中的段描述符创建访问的共享段。</p><p>如果启用分页，则 TSS 中的 CR3 寄存器 (PDBR) 字段允许每个任务拥有自己的一组页表，用于将线性地址映射到物理地址。或者，多个任务可以共享同一组页表。</p><h3 id="了解把任务映射到线性和物理地址空间的方法" tabindex="-1"><a class="header-anchor" href="#了解把任务映射到线性和物理地址空间的方法" aria-hidden="true">#</a> 了解把任务映射到线性和物理地址空间的方法？</h3><p>可以通过以下两种方式之一将任务映射到线性地址空间和物理地址空间：</p><ul><li><strong>所有任务共享一个从线性到物理地址空间的映射关系</strong>。当未启用分页时，这是唯一的选择。在没有分页的情况下，所有线性地址都映射到相同的物理地址。当启用分页时，这种形式的从线性到物理地址空间映射是通过对所有任务使用一个页目录来获得的。如果支持请求分页虚拟内存，线性地址空间可能会超过可用的物理空间。</li><li><strong>每个任务都有自己的</strong>被映射到物理地址空间的<strong>线性地址空间</strong>。这种映射形式是通过为每个任务使用不同的页面目录来实现的。因为PDBR（控制寄存器CR3）加载在任务开关上，每个任务可能有不同的页目录。</li></ul><p>不同任务的线性地址空间可能映射到完全不同的物理地址。如果不同页目录的条目指向不同的页表，而页表又指向物理内存的不同页，则任务不共享物理地址。</p><p>无论使用哪种映射任务线性地址空间的方法，<strong>所有任务的 TSS 都必须位于物理空间的共享区域中，所有任务都可以访问该区域</strong>。此映射是必需的，以便在任务切换期间处理器正在读取和更新 TSS 时，TSS 地址的映射不会更改。 GDT映射的线性地址空间也应该映射到物理空间的共享区域；否则，GDT 的目的就落空了。下图显示了两个任务的线性地址空间如何通过共享页表在物理空间中重叠。</p><figure><img src="/assets/overlapping_linear_to_physical_mappings-32f9ea53.png" alt="overlapping_linear_to_physical_mappings" tabindex="0"><figcaption>overlapping_linear_to_physical_mappings</figcaption></figure><h3 id="了解任务逻辑地址空间-及如何在任务之间共享数据的方法" tabindex="-1"><a class="header-anchor" href="#了解任务逻辑地址空间-及如何在任务之间共享数据的方法" aria-hidden="true">#</a> 了解任务逻辑地址空间，及如何在任务之间共享数据的方法？</h3><p>要允许在任务之间共享数据，请使用以下技术为数据段创建共享的逻辑到物理地址空间映射：</p><ul><li><strong>通过 GDT 中的段描述符</strong>：所有任务都一定能够访问 GDT 中的段描述符。如果 GDT 中的某些段描述符指向线性地址空间中的段，这些段映射到所有任务共有的物理地址空间区域，那么所有任务都可以共享这些段中的数据和代码。</li><li><strong>通过共享 LDT</strong>：如果 TSS 中的 LDT 字段指向相同的 LDT，则两个或多个任务可以使用相同的 LDT。如果共享 LDT 中的某些段描述符指向映射到物理地址空间公共区域的段，则这些段中的数据和代码可以在使用相同LDT的任务之间共享。这种共享方法比通过GDT共享更具选择性，因为共享可以限于特定任务。系统中的其他任务可能有不同的 LDT，这些 LDT 不允许它们访问共享段。</li><li><strong>通过不同 LDT 中的映射到线性地址空间中公共地址的段描述符</strong>：如果线性地址空间的这个公共区域映射到每个任务的物理地址空间的相同区域，这些段描述符允许任务共享段。这样的段描述符通常称为别名。这种共享方法比上面列出的方法更具选择性，因为 LDT 中的其他段描述符可能指向不共享的独立线性地址。</li></ul></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/jielahou/jielahou-blog/edit/main/docs/system/task_management.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><!----></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: jielahou@gmail.com">jielahou</span><!--]--><!--]--></div></footer><!----><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2023 jielahou</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-6b90294d.js" defer></script>
  </body>
</html>
