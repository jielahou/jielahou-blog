<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://mister-hope.github.io/system/interrupt_and_exception_handling.html"><meta property="og:site_name" content="Jielahou's Blog"><meta property="og:title" content="中断和异常处理"><meta property="og:description" content="中断和异常处理 中断和异常处理概述 什么是中断(Interupt)和异常(Exception)？ 处理器如何处理？ 思考：实模式和保护模式下，中断向量表一样吗？ 中断和异常是指系统、处理器或当前执行的程序或任务中存在需要处理器注意的事件。它们通常会导致执行从当前运行的程序或任务强制转移到一个称为中断处理程序或异常处理程序的特殊软件例程或任务。处理器响应中断或异常所采取的操作称为服务或处理中断或异常。 中断会在程序执行期间随机发生，作为对硬件信号的响应。系统硬件使用中断来处理处理器外部的事件，例如为外围设备提供服务的请求。软件也可以通过执行INT n指令来生成中断。"><meta property="og:type" content="article"><meta property="og:image" content="https://mister-hope.github.io/"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-05-16T02:21:26.000Z"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image:alt" content="中断和异常处理"><meta property="article:modified_time" content="2023-05-16T02:21:26.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"中断和异常处理","image":["https://mister-hope.github.io/"],"dateModified":"2023-05-16T02:21:26.000Z","author":[]}</script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js?id=KDeTDcfevxjOrgMS&ck=KDeTDcfevxjOrgMS"></script><title>中断和异常处理 | Jielahou's Blog</title><meta name="description" content="中断和异常处理 中断和异常处理概述 什么是中断(Interupt)和异常(Exception)？ 处理器如何处理？ 思考：实模式和保护模式下，中断向量表一样吗？ 中断和异常是指系统、处理器或当前执行的程序或任务中存在需要处理器注意的事件。它们通常会导致执行从当前运行的程序或任务强制转移到一个称为中断处理程序或异常处理程序的特殊软件例程或任务。处理器响应中断或异常所采取的操作称为服务或处理中断或异常。 中断会在程序执行期间随机发生，作为对硬件信号的响应。系统硬件使用中断来处理处理器外部的事件，例如为外围设备提供服务的请求。软件也可以通过执行INT n指令来生成中断。">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-028e366e.css" as="style"><link rel="stylesheet" href="/assets/style-028e366e.css">
    <link rel="modulepreload" href="/assets/app-5896a960.js"><link rel="modulepreload" href="/assets/framework-9e409b07.js"><link rel="modulepreload" href="/assets/interrupt_and_exception_handling.html-82492624.js"><link rel="modulepreload" href="/assets/interrupt_and_exception_handling.html-08fb8db4.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container no-sidebar has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><!----><!----><span class="site-name">Jielahou&#39;s Blog</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="主页"><span class="font-icon icon iconfont icon-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/intro.html" class="nav-link" aria-label="关于"><span class="font-icon icon iconfont icon-info" style=""></span>关于<!----></a></div><div class="nav-item hide-in-mobile"><a href="/link.html" class="nav-link" aria-label="友链"><span class="font-icon icon iconfont icon-link" style=""></span>友链<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/jielahou/jielahou-blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->中断和异常处理</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://jielahou.com" target="_blank" rel="noopener noreferrer">jielahou</a></span><span property="author" content="jielahou"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-05-16T02:21:26.000Z"></span><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 24 分钟</span><meta property="timeRequired" content="PT24M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#中断和异常处理概述" class="router-link-active router-link-exact-active toc-link level2">中断和异常处理概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#有关中断和异常了解性的内容" class="router-link-active router-link-exact-active toc-link level2">有关中断和异常了解性的内容</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#中断和中断向量" class="router-link-active router-link-exact-active toc-link level3">中断和中断向量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#中断源和异常源" class="router-link-active router-link-exact-active toc-link level3">中断源和异常源</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#异常的分类-故障、陷阱和中止" class="router-link-active router-link-exact-active toc-link level3">异常的分类：故障、陷阱和中止</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#程序或任务的重新执行" class="router-link-active router-link-exact-active toc-link level3">程序或任务的重新执行</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#开启和禁止中断" class="router-link-active router-link-exact-active toc-link level3">开启和禁止中断</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#异常和中断的优先级" class="router-link-active router-link-exact-active toc-link level3">异常和中断的优先级</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#中断描述符表" class="router-link-active router-link-exact-active toc-link level2">中断描述符表</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#如何构成" class="router-link-active router-link-exact-active toc-link level3">如何构成？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#如何获得中断处理程序的地址" class="router-link-active router-link-exact-active toc-link level3">如何获得中断处理程序的地址？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#如何设置中断描述符表寄存器" class="router-link-active router-link-exact-active toc-link level3">如何设置中断描述符表寄存器？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#idt-描述符" class="router-link-active router-link-exact-active toc-link level2">IDT 描述符</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#中断门-陷阱门" class="router-link-active router-link-exact-active toc-link level3">中断门&amp;陷阱门</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#任务门" class="router-link-active router-link-exact-active toc-link level3">任务门</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#中断与异常处理的相关思考" class="router-link-active router-link-exact-active toc-link level2">中断与异常处理的相关思考</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#中断过程调用的流程是怎样的" class="router-link-active router-link-exact-active toc-link level3">中断过程调用的流程是怎样的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#如何判断中断处理过程与被中断任务的优先级" class="router-link-active router-link-exact-active toc-link level3">如何判断中断处理过程与被中断任务的优先级？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#不同优先级上-处理方式一样吗" class="router-link-active router-link-exact-active toc-link level3">不同优先级上，处理方式一样吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#如果发生堆栈切换-处理器会做哪些操作" class="router-link-active router-link-exact-active toc-link level3">如果发生堆栈切换，处理器会做哪些操作？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#如果没发生堆栈切换-处理器会做哪些操作" class="router-link-active router-link-exact-active toc-link level3">如果没发生堆栈切换，处理器会做哪些操作？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#中断处理过程后-如何返回-处理器做了哪些操作" class="router-link-active router-link-exact-active toc-link level3">中断处理过程后，如何返回，处理器做了哪些操作？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#异常和中断处理过程的保护" class="router-link-active router-link-exact-active toc-link level3">异常和中断处理过程的保护</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#异常和中断处理过程的标志使用方式" class="router-link-active router-link-exact-active toc-link level3">异常和中断处理过程的标志使用方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/system/interrupt_and_exception_handling.html#中断门与陷阱门的唯一区别是什么" class="router-link-active router-link-exact-active toc-link level3">中断门与陷阱门的唯一区别是什么？</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="中断和异常处理" tabindex="-1"><a class="header-anchor" href="#中断和异常处理" aria-hidden="true">#</a> 中断和异常处理</h1><h2 id="中断和异常处理概述" tabindex="-1"><a class="header-anchor" href="#中断和异常处理概述" aria-hidden="true">#</a> 中断和异常处理概述</h2><blockquote><ul><li>什么是中断(Interupt)和异常(Exception)？</li><li>处理器如何处理？</li></ul><p>思考：实模式和保护模式下，中断向量表一样吗？</p></blockquote><p>中断和异常是指系统、处理器或当前执行的程序或任务中存在需要处理器注意的事件。它们通常会导致执行从当前运行的程序或任务强制转移到一个称为中断处理程序或异常处理程序的特殊软件例程或任务。处理器响应中断或异常所采取的操作称为服务或处理中断或异常。</p><p><strong>中断</strong>会在程序执行期间随机发生，作为对<strong>硬件信号</strong>的响应。系统硬件使用中断来处理处理器外部的事件，例如为外围设备提供服务的请求。软件也可以通过执行<code>INT n</code>指令来生成中断。</p><p><strong>异常</strong>在处理器<strong>执行指令</strong>的过程中，<strong>检测到错误</strong>条件时发出，例如除以零。处理器检测各种错误情况，包括保护冲突、页面故障和内部机器故障。奔腾4、英特尔至强、P6系列和奔腾处理器的机器检查架构还允许在检测到内部硬件错误和总线错误时生成机器检查异常。</p><p>当<strong>接收到中断</strong>或<strong>检测到异常</strong>时，当前正在运行的过程或任务将<strong>暂停</strong>，此时处理器<strong>执行中断或异常处理程序</strong>。当处理程序的执行完成时，处理程序将继续执行被中断的过程或任务。中断的过程或任务的恢复不会失去程序的连续性，除非无法从异常中恢复，或中断导致当前运行的程序终止。</p><blockquote><p>在<strong>实模式</strong>下，处理器的<strong>中断向量表总是位于内存地址0</strong>，而在<strong>保护模式</strong>下，中断向量表的位置存储在一个名为<strong>IDTR</strong>的CPU寄存器中。</p></blockquote><h2 id="有关中断和异常了解性的内容" tabindex="-1"><a class="header-anchor" href="#有关中断和异常了解性的内容" aria-hidden="true">#</a> 有关中断和异常了解性的内容</h2><blockquote><ul><li>中断和异常向量</li><li>中断源和异常源</li><li>异常的分类：故障、陷阱和中止</li><li>程序或任务的重新执行</li><li>开启和禁止中断</li><li>异常和中断的优先级</li></ul></blockquote><h3 id="中断和中断向量" tabindex="-1"><a class="header-anchor" href="#中断和中断向量" aria-hidden="true">#</a> 中断和中断向量</h3><p>为了帮助处理异常和中断，每个由架构定义的异常和每个需要处理器特殊处理的中断<strong>都被分配了一个唯一的标识号</strong>，称为<strong>中断向量号</strong>。处理器使用分配给异常或中断的向量号<strong>作为中断描述符表（IDT）的索引</strong>。该表提供了异常或中断处理程序的<strong>入口点</strong>（见第6.10节“中断描述符表（IDT）”）。<strong>中断向量号的允许范围是<code>0</code>到<code>255</code></strong>。<strong>范围为<code>0</code>到<code>31</code><strong>的中断向量号由英特尔64和IA-32</strong>架构保留</strong>，用于架构定义的异常和中断。并不是这个范围内的所有中断向量号都有当前被定义的函数。此范围中未分配的矢量号是保留的。不要使用保留的矢量号。</p><p><strong>范围在<code>32</code>到<code>255</code><strong>之间的中断向量号被指定为</strong>用户定义</strong>的中断，不由英特尔64和IA-32架构保留。这些中断通常分配给外部I/O设备，使这些设备能够通过一种外部硬件中断机制向处理器发送中断（见第6.3节“中断源”）。</p><h3 id="中断源和异常源" tabindex="-1"><a class="header-anchor" href="#中断源和异常源" aria-hidden="true">#</a> 中断源和异常源</h3><p>中断源有两种：</p><ul><li>外部中断(External (hardware generated) interrupts)</li><li>软件生成的中断(Software-generated interrupts)</li></ul><p>异常源有三种：</p><ul><li>处理器检测到程序错误异常(Processor-detected program-error exceptions)</li><li>软件生成的异常(Software-generated exceptions)</li><li>机器检查异常(Machine-check exceptions)</li></ul><h3 id="异常的分类-故障、陷阱和中止" tabindex="-1"><a class="header-anchor" href="#异常的分类-故障、陷阱和中止" aria-hidden="true">#</a> 异常的分类：故障、陷阱和中止</h3><p>异常被分类为<strong>故障、陷阱或中止</strong>，这取决于它们的报告方式以及导致异常的指令是否可以在不损失程序或任务连续性的情况下重新启动。</p><ul><li><strong>故障</strong>(Fault)：故障是一种通常<strong>可以纠正</strong>的<strong>异常</strong>，一旦纠正，就可以在不丧失连续性的情况下重新启动程序。当报告故障时，处理器将机器状态<strong>恢复到故障指令开始执行之前的状态</strong>。故障处理程序的<strong>返回地址</strong>（CS和EIP寄存器的保存内容）指向<strong>引起故障的指令</strong>，而不是故障指令后面的指令。</li></ul><figure><img src="/assets/fault-0cbb7c24.png" alt="fault" tabindex="0"><figcaption>fault</figcaption></figure><ul><li><strong>陷阱</strong>(Trap)：陷阱是在<strong>执行陷阱指令后立即报告的异常</strong>。陷阱允许程序或任务继续执行，而不会失去程序的连续性。陷阱处理程序的<strong>返回地址</strong>指向<strong>陷阱指令之后</strong>要执行<strong>的指令</strong>。</li></ul><figure><img src="/assets/trap-88ba069e.png" alt="trap" tabindex="0"><figcaption>trap</figcaption></figure><ul><li><strong>中止</strong>(Abort)：中止是一种异常，它并不总是报告导致异常的指令的精确位置，并且<strong>不允许重新启动导致异常的程序或任务</strong>。中止用于报告严重错误，例如硬件错误和系统表中不一致或非法的值。</li></ul><figure><img src="/assets/abort-697e7341.png" alt="abort" tabindex="0"><figcaption>abort</figcaption></figure><h3 id="程序或任务的重新执行" tabindex="-1"><a class="header-anchor" href="#程序或任务的重新执行" aria-hidden="true">#</a> 程序或任务的重新执行</h3><p>为了允许在处理异常或中断后重新启动程序或任务，所有<strong>异常</strong>(中止除外)都保证在指令边界上报告异常。所有中断都保证发生在指令边界上。所有<strong>中断</strong>都保证在指令边界上发生。</p><p>对于<strong>故障类异常</strong>，<strong>返回指令指针</strong>（在处理器产生异常时保存）<strong>指向导致错误的指令</strong>。因此，当程序或任务在处理故障后重新启动时，故障指令将重新启动（重新执行）。<strong>重启错误指令</strong>通常用于<strong>处理访问被阻止</strong>时生成的异常。此类错误最常见的示例是页面错误异常 (<code>#PF</code>)，当程序或任务引用位于不在内存中的页面上的操作数时，就会发生这种情况。当发生页面错误异常时，异常处理程序可以将页面加载到内存中，并通过重新启动错误指令来恢复程序或任务的执行。为确保重新启动对当前正在执行的程序或任务是透明的，处理器<strong>保存必要的寄存器和堆栈指针</strong>以允许重新启动到执行错误指令之前的状态。</p><p>对于<strong>陷阱类异常</strong>，<strong>返回指令指针</strong>指向<strong>陷阱指令之后的指令</strong>。如果在<strong>执行转移指令时检测到陷阱</strong>，则返回指令指针会体现转移。例如，如果在<strong>执行 <code>JMP</code> 指令时检测到陷阱</strong>，则<strong>返回指令指针指向 <code>JMP</code> 指令的目标</strong>，而不是指向 <code>JMP</code> 指令之后的下一个地址。所有陷阱异常都允许程序或任务重新启动而不会失去连续性。例如溢出异常就是陷阱异常。对于溢出异常，返回指令指针指向 <code>INTO</code> 指令（测试 <code>EFLAGS.OF</code>（溢出标志））的之后的指令。此异常的陷阱处理程序解决了溢出情况。从陷阱处理程序返回后，程序或任务将继续执行 <code>INTO</code> 指令之后的指令。</p><p>对于<strong>中止类异常</strong>，<strong>不支持</strong>程序或任务的可靠<strong>重启</strong>。中止处理程序旨在<strong>收集</strong>有关发生中止异常时处理器状态的<strong>诊断信息</strong>，然后尽可能优雅地<strong>关闭应用程序和系统</strong>。</p><p>对于<strong>中断</strong>，严格<strong>支持重新启动</strong>被中断的程序和任务，而不会失去连续性。<strong>为中断保存的返回指令指针</strong>指向要在处理器接受中断的指令边界处执行的下一条指令。如果刚刚执行的指令有一个重复前缀，则在当前迭代结束时方才处理中断，并将寄存器设置为执行下一次迭代。</p><p>P6 系列处理器推测执行指令的能力不会影响处理器接受中断。中断发生在位于指令执行退出阶段的指令边界处；所以它们(指发生的中断)总是被带入“有序”指令流中。</p><p>请注意，奔腾处理器和更早的 IA-32 处理器也执行不同数量的预取和初步解码。对于这些处理器，在指令实际“按顺序”执行之前，不会发出异常和中断信号。对于给定的代码示例，当代码在任何 IA-32 处理器系列上执行时，异常信号统一发生（除非定义了新异常或新操作码）。</p><blockquote><p>好像是在说，虽然指令的执行是乱序的，但是抛出异常和中断是有序的</p></blockquote><h3 id="开启和禁止中断" tabindex="-1"><a class="header-anchor" href="#开启和禁止中断" aria-hidden="true">#</a> 开启和禁止中断</h3><p>处理器会根据处理器的状态以及 <code>EFLAGS</code> 寄存器中的 <code>IF</code> 和 <code>RF</code> 标志的状态来抑制(inhibit)某些中断的产生，如以下部分所述。</p><h4 id="屏蔽可屏蔽的硬件中断" tabindex="-1"><a class="header-anchor" href="#屏蔽可屏蔽的硬件中断" aria-hidden="true">#</a> 屏蔽可屏蔽的硬件中断</h4><p><strong><code>IF</code> 标志可以禁用</strong>由处理器的 <code>INTR</code> 引脚上或通过本地 <code>APIC</code> 引起的<strong>可屏蔽硬件中断</strong>（请参阅第 6.3.2 节“可屏蔽硬件中断”）。当 <code>IF</code> 标志清0时，处理器禁止传递到 <code>INTR</code> 引脚或通过本地 <code>APIC</code> 产生内部中断请求的中断；当 <code>IF</code> 标志置1时，传送到 <code>INTR</code> 或通过本地 <code>APIC</code> 引脚引起中断将作为正常的外部中断处理。</p><p><strong><code>IF</code> 标志不影响</strong>传递到 NMI 引脚、或通过本地 APIC 传递的传递模式 NMI 消息导致的<strong>不可屏蔽中断</strong> (NMI) ，也不影响处理器生成的异常。与 <code>EFLAGS</code> 寄存器中的其他标志一样，处理器<strong>清除 <code>IF</code> 标志以响应硬件复位</strong>。</p><blockquote><p>想起来Linux 0.00 <code>Boot.s</code>中，在将<code>Head.s</code>从<code>0x10000</code>复制到<code>0x0</code>的过程中，一开始就把<code>IF</code>给清零了</p></blockquote><p>事实上，<strong>可屏蔽硬件中断</strong>组<strong>包括保留中断和异常向量 <code>0</code> 到 <code>32</code></strong>，这可能会导致疑惑。在体系结构上，当设置 <code>IF</code> 标志时，从 <code>0</code> 到 <code>32</code> 的任何向量的中断都可以通过 <code>INTR</code> 引脚传送到处理器，并且可以通过本地 APIC 传送从 <code>16</code> 到 <code>32</code> 的任何向量。然后处理器将产生中断并调用向量号指向的中断或异常处理程序。因此，例如，可以通过 <code>INTR</code> 引脚调用页面错误处理程序（通过向量 <code>14</code>）；但是，这不是真正的页面错误异常，这是一个中断。对于 <code>INT n</code> 指令（请参阅第 6.4.2 节“软件生成的异常”），当通过 <code>INTR</code> 引脚向异常向量生成中断时，处理器不会将错误代码压入堆栈，因此异常处理程序可能无法正常运行。</p><blockquote><p>异常会调用对应的中断向量表中的处理程序，当然也可以手动使用<code>INT n</code>直接去调用。但是异常在调用的时候可能会输入额外的信息，手动调用就不会输入额外的信息了，所以手动调用可能会出问题。</p></blockquote><p>可以分别<strong>使用 <code>STI</code>（设置中断允许标志）和 <code>CLI</code>（清除中断允许标志）指令设置或清除 IF 标志</strong>。仅当 <code>CPL</code> 小于等于 <code>IOPL</code> 时，才可以执行这些指令。如果在 <code>CPL</code> 大于 <code>IOPL</code> 时执行它们，则会生成一般保护异常 (<code>#GP</code>)。 （当通过在控制寄存器 <code>CR4</code> 中设置 <code>VME</code> 标志启用虚拟模式扩展时，<code>IOPL</code> 对这些指令的影响略有修改：请参阅第 20.3 节，“虚拟 8086 模式下的中断和异常处理”。行为也受到影响PVI 标志：参见第 20.4 节“保护模式虚拟中断”。）</p><p><code>IF</code> 标志还受以下操作的影响：</p><ul><li><code>PUSHF</code> 指令将所有标志存储在堆栈中，可以在其中检查和修改它们。 <code>POPF</code> 指令可用于将修改后的标志加载回 <code>EFLAGS</code> 寄存器。</li><li>任务切换以及<code>POPF</code> 和 <code>IRET</code> 指令加载 <code>EFLAGS</code> 寄存器；因此，它们可用于修改 <code>IF</code> 标志的设置。</li><li>通过中断门处理中断时，<code>IF</code> 标志会自动清除，从而禁用可屏蔽硬件中断。 （如果中断是通过陷阱门处理的，则 <code>IF</code> 标志不会被清除。）</li></ul><blockquote><p>See the descriptions of the CLI, STI, PUSHF, POPF, and IRET instructions in Chapter 3, “Instruction Set Reference, A-M,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A, and Chapter 4, “Instruction Set Reference, N-Z,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2B, for a detailed description of the operations these instructions are allowed to perform on the IF flag.</p></blockquote><h4 id="屏蔽指令断点" tabindex="-1"><a class="header-anchor" href="#屏蔽指令断点" aria-hidden="true">#</a> 屏蔽指令断点</h4><blockquote><p>Masking Instruction Breakpoints</p></blockquote><p>EFLAGS寄存器中的**<code>RF</code>（恢复）标志<strong>控制处理器对</strong>指令断点**条件的响应(see the description of the RF flag in Section 2.3, “System Flags and Fields in the EFLAGS Register”)。</p><p>置1时，它会阻止指令断点生成调试异常（<code>#DB</code>）；清0时，指令断点将生成调试异常。RF标志的主要功能是防止处理器在指令断点上进入调试异常循环。</p><blockquote><p>See Section 17.3.1.1, “Instruction-Breakpoint Exception Condition,” for more information on the use of this flag.</p></blockquote><h4 id="屏蔽任务切换时的异常和中断" tabindex="-1"><a class="header-anchor" href="#屏蔽任务切换时的异常和中断" aria-hidden="true">#</a> 屏蔽任务切换时的异常和中断</h4><p>要切换到不同的堆栈段，软件通常使用一对指令，例如：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>MOV SS, AX
MOV ESP, StackTop
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在段选择子加载到<code>SS</code>寄存器之后但在<code>ESP</code>寄存器加载之前发生了中断或异常，则在中断或异常处理程序执行期间，堆栈空间逻辑地址的段选择子和段偏移是不匹配的。</p><p>为了防止这种情况，处理器在<code>MOV</code>到<code>SS</code>指令或<code>POP</code>到<code>SS</code>指令之后禁止中断、调试异常和单步陷阱异常，直到达到下一条指令之后的指令边界。所有其他故障仍可能产生。如果<code>LSS</code>指令用于修改SS寄存器的内容（这是修改此寄存器的推荐方法），则不会出现此问题。</p><h3 id="异常和中断的优先级" tabindex="-1"><a class="header-anchor" href="#异常和中断的优先级" aria-hidden="true">#</a> 异常和中断的优先级</h3><p>如果在指令边界处有多个异常或中断，处理器将按既定顺序为它们提供服务。下表显示了异常和中断源之间的优先级。</p><table><thead><tr><th>优先级</th><th>描述</th></tr></thead><tbody><tr><td>1(最高)</td><td>Hardware Reset and Machine Checks<br>- RESET<br>- Machine Check</td></tr><tr><td>2</td><td>Trap on Task Switch(任务切换陷阱)<br>- T flag in TSS is set</td></tr><tr><td>3</td><td>External Hardware Interventions(外部硬件)<br>- FLUSH<br>- STOPCLK<br>- SMI<br>- INIT</td></tr><tr><td>4</td><td>Traps on the Previous Instruction(上一条指令的陷阱)<br>- Breakpoints(断点)<br>- Debug Trap Exceptions(调试陷阱异常) (TF flag set or data/I-O breakpoint)</td></tr><tr><td>5</td><td>Nonmaskable Interrupts(不可屏蔽中断) (NMI)</td></tr><tr><td>6</td><td>Maskable Hardware Interrupts(可屏蔽硬件中断)</td></tr><tr><td>7</td><td>Code Breakpoint Fault(代码断点故障)</td></tr><tr><td>8</td><td>Faults from Fetching Next Instruction(取下一条指令时的故障) <br>- Code-Segment Limit Violation<br>- Code Page Fault</td></tr><tr><td>9</td><td>Faults from Decoding the Next Instruction(译码下一条指令时的故障) <br>- Instruction length &gt; 15 bytes <br>- Invalid Opcode <br>- Coprocessor Not Available</td></tr><tr><td>10(最低)</td><td>Faults on Executing an Instruction<br>- Overflow/Bound error/Invalid TSS/Segment Not Present/Stack fault/General Protection/Data Page Fault/Alignment Check/x87 FPU Floating-point exception/SIMD floating-point exception/Virtualization exception</td></tr></tbody></table><blockquote><p>注：英特尔486处理器和早期处理器将不可屏蔽中断和可屏蔽中断分组在同一优先级类别中。</p></blockquote><p>虽然表中列出的优先级在整个体系结构中是一致的，但每个优先级内异常的优先级都取决于实现，并且可能因处理器而异。</p><p>处理器<strong>首先处理具有最高优先级的、尚未处理的异常或中断</strong>，将执行转移到处理函数的第一条指令。<strong>优先级较低的<em>异常</em>被<em>丢弃</em></strong>；<strong>优先级较低的<em>中断</em>保持<em>等待</em></strong>。</p><p>虽然优先级较低的异常被丢弃了，但当中断处理程序将执行<strong>返回到程序或任务中发生异常和/或中断的点</strong>时，将<strong>重新生成被丢弃的异常</strong>。</p><h2 id="中断描述符表" tabindex="-1"><a class="header-anchor" href="#中断描述符表" aria-hidden="true">#</a> 中断描述符表</h2><blockquote><ul><li>如何构成？</li><li>如何获得中断处理程序的地址？</li><li>如何设置中断描述符表寄存器？</li></ul></blockquote><h3 id="如何构成" tabindex="-1"><a class="header-anchor" href="#如何构成" aria-hidden="true">#</a> 如何构成？</h3><p>中断描述符表（IDT）<strong>将每个异常或中断向量与</strong>用于服务相关联的<strong>异常或中断的过程、任务的门描述符</strong>相关联。与GDT和LDT一样，IDT是一个<strong>8字节描述符的数组</strong>（在保护模式下）。与GDT不同，<strong>IDT的第一个条目可能包含描述符</strong>。为了在IDT中形成索引，处理器将异常或中断向量缩放八（门描述符中的字节数）。因为只有256个中断或异常向量，所以IDT不需要包含超过256个描述符。它可以包含少于256个描述符，因为描述符仅用于可能发生的中断和异常向量。IDT中的所有空描述符都应将描述符的当前标志设置为0。</p><p>IDT的基地址应该在8字节的边界上对齐，以最大限度地提高缓存线填充(cache line fills)的性能。表界限以字节表示，表界限添加到基地址以获得IDT最后一个有效字节的地址。界限值为0会产生正好1个有效字节。因为IDT条目总是八个字节长，所以限制应该总是比八的整数倍少一个（即<code>8N–1</code>）。</p><p>IDT可以位于线性地址空间中的任何位置。如下图所示，处理器使用<code>IDTR</code>寄存器定位IDT。此寄存器同时保存32位基址和IDT的16位表界限。</p><figure><img src="/assets/idtr_and_idt-41810cad.png" alt="idtr_and_idt" tabindex="0"><figcaption>idtr_and_idt</figcaption></figure><h3 id="如何获得中断处理程序的地址" tabindex="-1"><a class="header-anchor" href="#如何获得中断处理程序的地址" aria-hidden="true">#</a> 如何获得中断处理程序的地址？</h3><p>处理器处理对异常和中断处理程序的调用，类似于用<code>CALL</code>指令处理对过程或任务的调用。当响应异常或中断时，<strong>处理器使用异常或中断向量作为IDT中描述符的索引</strong>。如果索引指向中断门或陷阱门，则处理器以类似于对调用门的CALL的方式调用异常或中断处理程序。如果索引指向任务门，则处理器以类似于CALL到任务门的方式执行到异常或中断处理程序任务的任务切换。</p><blockquote><p>如果向量引用的描述符超出了IDT的表界限，则会生成一般保护异常（<code>#GP</code>）。</p></blockquote><p><strong>中断门或陷阱门</strong>引用在当前执行任务的上下文中运行的异常或中断处理程序过程。门的<strong>段选择子指向</strong>GDT或当前LDT中可执行代码段的<strong>段描述符</strong>。门<strong>描述符</strong>的偏移字段<strong>指向异常或中断处理过程的入口</strong>。</p><blockquote><p>总结：中断向量是IDT的索引，从IDT中取出的门描述符中，包含一个LDT/GDT的段选择子和偏移。由段选择子获得段的基地址后，加上偏移，才是最终的地址。</p></blockquote><figure><img src="/assets/interupt_procedure_call-7c43ed25.png" alt="interupt_procedure_call" tabindex="0"><figcaption>interupt_procedure_call</figcaption></figure><p>当通过IDT中的<strong>任务门</strong>访问异常或中断处理程序时，会产生任务切换。用单独的任务处理异常或中断有几个优点：</p><ul><li>被中断的程序或任务的整个上下文将自动保存；</li><li>新的TSS允许处理程序在处理异常或中断时使用新的特权级别0堆栈。如果当前特权级别0堆栈损坏时发生异常或中断，则通过任务门访问处理程序可以通过为处理程序提供新的特权级别0栈来防止系统崩溃。</li><li>通过给处理程序一个单独的地址空间，可以将其与其他任务进一步隔离。这是通过给它一个单独的LDT来完成的。</li></ul><p>用单独的任务处理中断的缺点是，在任务交换时必须保存大量的机器状态，因而使其比使用中断门慢，从而导致中断延迟增加。</p><p>IDT中的任务门引用GDT中的TSS描述符（见下图）。切换到处理程序任务的处理方式与普通任务切换相同(see Section 7.3, “Task Switching”)。返回中断任务的链接存储在处理程序任务的TSS的上一个任务链接字段中。如果异常导致生成错误代码，则会将此错误代码复制到新任务的堆栈中。</p><figure><img src="/assets/interrupt_task_switch-c9c0df12.png" alt="interrupt_task_switch" tabindex="0"><figcaption>interrupt_task_switch</figcaption></figure><h3 id="如何设置中断描述符表寄存器" tabindex="-1"><a class="header-anchor" href="#如何设置中断描述符表寄存器" aria-hidden="true">#</a> 如何设置中断描述符表寄存器？</h3><p><code>LIDT</code>（加载IDT寄存器）和<code>SIDT</code>（存储IDT寄存器）指令分别加载和存储<code>IDTR</code>寄存器的内容。<code>LIDT</code>指令加载<code>IDTR</code>寄存器，其中基址和表界限保存在内存操作数中。只有当CPL为0时，才能执行此指令。它通常由操作系统的初始化代码在创建IDT时使用。操作系统也可以使用它改变IDT。<code>SIDT</code>指令将存储在<code>IDTR</code>中的基址和表界限复制到内存中。此指令可以在任何特权级别执行。</p><h2 id="idt-描述符" tabindex="-1"><a class="header-anchor" href="#idt-描述符" aria-hidden="true">#</a> IDT 描述符</h2><p>掌握以下描述符格式：</p><blockquote><ul><li>中断门</li><li>陷阱门</li><li>任务门</li></ul></blockquote><h3 id="中断门-陷阱门" tabindex="-1"><a class="header-anchor" href="#中断门-陷阱门" aria-hidden="true">#</a> 中断门&amp;陷阱门</h3><blockquote><p>Interrupt-gate descriptor &amp; Trap-gate descriptor, 手册P180, 6.11 IDT DESCRIPTORS</p></blockquote><p>中断门和陷阱门同调用门（见第5.8.3节“调用门”）非常相似。它们包含一个远指针（段选择器和偏移量），处理器使用该指针将程序执行转移到异常或中断处理程序代码段中的处理程序过程。这些门的不同之处在于处理器处理EFLAGS寄存器中IF标志的方式（参见第6.12.1.2节“异常或中断处理程序使用标志”）。</p><figure><img src="/assets/interrupt_and_trap_gate-6c706c3a.png" alt="interrupt_and_trap_gate" tabindex="0"><figcaption>interrupt_and_trap_gate</figcaption></figure><h3 id="任务门" tabindex="-1"><a class="header-anchor" href="#任务门" aria-hidden="true">#</a> 任务门</h3><blockquote><p>Task-gate descriptor, 手册P180, 6.11 IDT DESCRIPTORS;手册P230, 7.2.5 Task-Gate Descriptor</p></blockquote><p>IDT中使用的任务门的格式与GDT或LDT中的任务门格式相同（见第7.2.5节，“任务门描述符”）。任务门包含异常和/或中断处理程序任务的TSS的段选择子。</p><p>任务门描述符提供了对任务的间接、受保护的引用。它可以放置在GDT、LDT或IDT中。任务门描述符中的TSS段选择子字段指向GDT中的TSS描述符，段选择子中的<code>RPL</code>未使用。</p><p>任务门描述符的DPL控制在任务切换期间对TSS描述符的访问。当程序或过程通过任务门调用或跳转到任务时，指向任务门的门选择子的<code>CPL</code>和<code>RPL</code>字段必须小于或等于任务门描述符的<code>DPL</code>。请注意，当使用任务门时，目标TSS描述符的<code>DPL</code>不被使用。</p><figure><img src="/assets/task_gate_descriptor-e1d21a65.png" alt="task_gate_descriptor" tabindex="0"><figcaption>task_gate_descriptor</figcaption></figure><h2 id="中断与异常处理的相关思考" tabindex="-1"><a class="header-anchor" href="#中断与异常处理的相关思考" aria-hidden="true">#</a> 中断与异常处理的相关思考</h2><h3 id="中断过程调用的流程是怎样的" tabindex="-1"><a class="header-anchor" href="#中断过程调用的流程是怎样的" aria-hidden="true">#</a> 中断过程调用的流程是怎样的？</h3><p>答：触发中断--&gt;查IDT获取处理函数地址，保存必要的信息--&gt;执行处理函数--&gt;（看情况）返回</p><h3 id="如何判断中断处理过程与被中断任务的优先级" tabindex="-1"><a class="header-anchor" href="#如何判断中断处理过程与被中断任务的优先级" aria-hidden="true">#</a> 如何判断中断处理过程与被中断任务的优先级？</h3><p>答：如果“被中断任务”是普通的任务，那么只要没关中断，都会触发对应的中断处理过程；</p><p>如果“被中断任务”本身是中断处理过程，此时要考虑“相应处理优先级”来比较被中断任务与新中断的优先级。</p><h3 id="不同优先级上-处理方式一样吗" tabindex="-1"><a class="header-anchor" href="#不同优先级上-处理方式一样吗" aria-hidden="true">#</a> 不同优先级上，处理方式一样吗？</h3><p>答：对于每一个具体的优先级，其内部各种情况的优先级要看架构的具体实现。</p><h3 id="如果发生堆栈切换-处理器会做哪些操作" tabindex="-1"><a class="header-anchor" href="#如果发生堆栈切换-处理器会做哪些操作" aria-hidden="true">#</a> 如果发生堆栈切换，处理器会做哪些操作？</h3><p>答：如果处理程序过程将以较低的特权级别执行，则会发生堆栈切换。</p><p>当堆栈切换发生时：</p><ol><li>处理程序要使用的堆栈的段选择器和堆栈指针是从当前执行任务的TSS中获得的。<strong>在这个新堆栈上，处理器将被中断过程的堆栈段选择子和堆栈指针入栈</strong>；</li><li>然后，处理器<strong>将<code>EFLAGS</code>、<code>CS</code>和<code>EIP</code>寄存器的当前状态保存在新堆栈</strong>上；</li><li>如果要保存异常的错误代码，则会将其压入到<code>EIP</code>值之后的新堆栈上。</li></ol><figure><img src="/assets/stack_usage_with_privilege_change-f09c1b70.png" alt="stack_usage_with_privilege_change" tabindex="0"><figcaption>stack_usage_with_privilege_change</figcaption></figure><blockquote><p>参考6.12.1 Exception- or Interrupt-Handler Procedures</p></blockquote><h3 id="如果没发生堆栈切换-处理器会做哪些操作" tabindex="-1"><a class="header-anchor" href="#如果没发生堆栈切换-处理器会做哪些操作" aria-hidden="true">#</a> 如果没发生堆栈切换，处理器会做哪些操作？</h3><p>答：如果中断处理程序过程将以与被中断过程相同的权限级别执行，此时不发生堆栈切换，处理器执行：</p><ol><li>处理器<strong>将<code>EFLAGS</code>、<code>CS</code>和<code>EIP</code>寄存器的当前状态保存在<em>当前堆栈</em></strong>上；</li><li>如果要保存异常的错误代码，则会将其压入到<code>EIP</code>值之后的当前堆栈上。</li></ol><figure><img src="/assets/stack_usage_with_no_privilege_level_change-fa1817ed.png" alt="stack_usage_with_no_privilege_level_change" tabindex="0"><figcaption>stack_usage_with_no_privilege_level_change</figcaption></figure><blockquote><p>参考6.12.1 Exception- or Interrupt-Handler Procedures</p></blockquote><h3 id="中断处理过程后-如何返回-处理器做了哪些操作" tabindex="-1"><a class="header-anchor" href="#中断处理过程后-如何返回-处理器做了哪些操作" aria-hidden="true">#</a> 中断处理过程后，如何返回，处理器做了哪些操作？</h3><p>要从异常或中断处理程序过程返回，处理程序<strong>必须使用<code>IRET</code>（或<code>IRETD</code>）指令</strong>。</p><p><code>IRET</code>指令与<code>RET</code>指令类似，但<code>IRET</code>指令还要<strong>将调用中断处理程序时保存的标志恢复到<code>EFLAGS</code>寄存器中</strong>。只有当<code>CPL</code>为0时，才会恢复<code>EFLAGS</code>寄存器的<code>IOPL</code>字段。只有当<code>CPL</code>小于或等于<code>IOPL</code>时，才会更改<code>IF</code>标志。</p><p>如果调用处理程序过程时发生堆栈切换，则IRET指令<strong>在返回时切换回中断过程的堆栈</strong>。</p><blockquote><p>参考6.12.1 Exception- or Interrupt-Handler Procedures</p></blockquote><h3 id="异常和中断处理过程的保护" tabindex="-1"><a class="header-anchor" href="#异常和中断处理过程的保护" aria-hidden="true">#</a> 异常和中断处理过程的保护</h3><p>异常和中断处理程序过程的特权级别保护类似于通过调用门调用普通过程的特权级别(see Section 5.8.4, “Accessing a Code Segment Through a Call Gate”)。 处理器不允许将执行转移到特权低于CPL的代码段（数字上的特权级别更高）中的异常或中断处理程序过程。</p><p>试图违反此规则会导致一般保护异常（<code>#GP</code>）。异常和中断处理程序过程的保护机制在以下方面有所不同：</p><ul><li>因为中断和异常向量没有<code>RPL</code>，所以在对异常和中断处理程序的隐式调用中不会检查<code>RPL</code>；</li><li>只有当<code>INT n</code>、<code>INT 3</code>或<code>INTO</code>指令产生异常或中断时，处理器才会检查中断或陷阱门的DPL。此时，CPL必须小于或等于门的DPL。此限制可防止以特权级别3运行的应用程序或过程使用软件中断访问关键异常处理程序，如页面错误处理程序，前提是这些处理程序位于特权更高的代码段中（在数字上较低的特权级别）。对于硬件生成的中断和处理器检测到的异常，处理器会忽略中断和陷阱门的DPL。</li></ul><p>由于异常和中断通常不会在可预测的时间发生，因此这些特权规则有效地限制了异常和中断处理过程可以运行的特权级别。可以使用以下任一技术来避免违反权限级别：</p><ul><li>异常或中断处理程序可以放置在一致的代码段中。这种技术可以用于只需要访问堆栈上可用数据的处理程序（例如，划分错误异常）。如果处理程序需要来自数据段的数据，则需要从权限级别3访问该数据段，这将使其不受保护。</li><li>处理程序可以放置在权限级别为0的不一致代码段中。无论被中断的程序或任务在哪个CPL上运行，该处理程序都将始终运行。</li></ul><h3 id="异常和中断处理过程的标志使用方式" tabindex="-1"><a class="header-anchor" href="#异常和中断处理过程的标志使用方式" aria-hidden="true">#</a> 异常和中断处理过程的标志使用方式</h3><p>答：当通过中断门或陷阱门访问异常或中断处理程序时，处理器在堆栈上保存<code>EFLAGS</code>寄存器的内容后，清除<code>EFLAGS</code>寄存器中的<code>TF</code>标志。（在调用异常和中断处理程序时，处理器还会在<code>EFLAGS</code>寄存器中的<code>VM</code>、<code>RF</code>和<code>NT</code>标志保存在堆栈上后清除这些标志。）清除<code>TF</code>标志可防止指令跟踪影响中断响应。随后的<code>IRET</code>指令将<code>TF</code>（以及<code>VM</code>、<code>RF</code>和<code>NT</code>）标志恢复为堆栈上<code>EFLAGS</code>寄存器的保存内容中的值。</p><blockquote><p>参考6.12.1.2 Flag Usage By Exception- or Interrupt-Handler Procedure，P184</p></blockquote><h3 id="中断门与陷阱门的唯一区别是什么" tabindex="-1"><a class="header-anchor" href="#中断门与陷阱门的唯一区别是什么" aria-hidden="true">#</a> 中断门与陷阱门的唯一区别是什么？</h3><p>答：中断门和陷阱门之间的<strong>唯一区别是处理器处理<code>EFLAGS</code>寄存器中<code>IF</code>标志的方式</strong>。当<strong>通过中断门</strong>访问异常或中断处理过程时，<strong>处理器清除<code>IF</code>标志</strong>，以防止其他中断干扰当前中断处理程序。随后的<code>IRET</code>指令将<code>IF</code>标志恢复到堆栈上<code>EFLAGS</code>寄存器保存内容中的值。<strong>通过陷阱门访问</strong>处理程序过程<strong>不会影响<code>IF</code>标志</strong>。</p><blockquote><p>参考6.12.1.2 Flag Usage By Exception- or Interrupt-Handler Procedure，P184</p></blockquote></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/jielahou/jielahou-blog/edit/main/docs/system/interrupt_and_exception_handling.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><!----></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: jielahou@gmail.com">jielahou</span><!--]--><!--]--></div></footer><!----><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2023 jielahou</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-5896a960.js" defer></script>
  </body>
</html>
