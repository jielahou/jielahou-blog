<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://mister-hope.github.io/compile/flex_bison.html"><meta property="og:site_name" content="Jielahou's Blog"><meta property="og:title" content="Flex Bison初体验"><meta property="og:description" content="近来要做编译原理的实验，需要使用Flex和Bison这两款重量级工具。实验手册有30多页，在这里稍作总结（其实就是把重要的部分Copy一份出来）。 “实验手册”指NJU南京大学的编译实验手册，俺虽然不是NJU学僧，但老师发的就是NJU的材料。羡慕NJU！ 若涉嫌侵权请联系我删除，谢谢！ 实验过程中的教训 Flex **符号|左右别有空格！**否则会报unrecognized rule。譬如："><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-04-03T06:44:22.000Z"><meta property="article:modified_time" content="2023-04-03T06:44:22.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Flex Bison初体验","image":[""],"dateModified":"2023-04-03T06:44:22.000Z","author":[]}</script><title>Flex Bison初体验 | Jielahou's Blog</title><meta name="description" content="近来要做编译原理的实验，需要使用Flex和Bison这两款重量级工具。实验手册有30多页，在这里稍作总结（其实就是把重要的部分Copy一份出来）。 “实验手册”指NJU南京大学的编译实验手册，俺虽然不是NJU学僧，但老师发的就是NJU的材料。羡慕NJU！ 若涉嫌侵权请联系我删除，谢谢！ 实验过程中的教训 Flex **符号|左右别有空格！**否则会报unrecognized rule。譬如：">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-fecc1033.css" as="style"><link rel="stylesheet" href="/assets/style-fecc1033.css">
    <link rel="modulepreload" href="/assets/app-04f92937.js"><link rel="modulepreload" href="/assets/framework-e03e056c.js"><link rel="modulepreload" href="/assets/flex_bison.html-4d06d35d.js"><link rel="modulepreload" href="/assets/flex_bison.html-0fb29656.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container no-sidebar has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><!----><!----><span class="site-name">Jielahou&#39;s Blog</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="主页"><span class="font-icon icon iconfont icon-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/intro.html" class="nav-link" aria-label="关于"><span class="font-icon icon iconfont icon-info" style=""></span>关于<!----></a></div><div class="nav-item hide-in-mobile"><a href="/link.html" class="nav-link" aria-label="友链"><span class="font-icon icon iconfont icon-link" style=""></span>友链<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-right"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/jielahou/jielahou-blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Flex Bison初体验</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://jielahou.com" target="_blank" rel="noopener noreferrer">jielahou</a></span><span property="author" content="jielahou"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-03-12T09:48:30.000Z"></span><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 23 分钟</span><meta property="timeRequired" content="PT23M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#flex" class="router-link-active router-link-exact-active toc-link level2">Flex</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#bison" class="router-link-active router-link-exact-active toc-link level2">Bison</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#cheatsheet" class="router-link-active router-link-exact-active toc-link level2">CheatSheet</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#词法分析概述" class="router-link-active router-link-exact-active toc-link level2">词法分析概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#gnu-flex介绍" class="router-link-active router-link-exact-active toc-link level2">GNU Flex介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#编写源代码" class="router-link-active router-link-exact-active toc-link level2">编写源代码</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#书写正则表达式" class="router-link-active router-link-exact-active toc-link level2">书写正则表达式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#高级特性" class="router-link-active router-link-exact-active toc-link level2">高级特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#语法分析概述" class="router-link-active router-link-exact-active toc-link level2">语法分析概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#gnu-bison介绍" class="router-link-active router-link-exact-active toc-link level2">GNU Bison介绍</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#编写源代码-1" class="router-link-active router-link-exact-active toc-link level2">编写源代码</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#属性值的类型" class="router-link-active router-link-exact-active toc-link level2">属性值的类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#语法单元的位置" class="router-link-active router-link-exact-active toc-link level2">语法单元的位置</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/compile/flex_bison.html#错误恢复" class="router-link-active router-link-exact-active toc-link level2">错误恢复</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><blockquote><p>近来要做编译原理的实验，需要使用Flex和Bison这两款重量级工具。实验手册有30多页，在这里稍作总结（其实就是把重要的部分Copy一份出来）。</p><p>“实验手册”指<strong>NJU南京大学的编译实验手册</strong>，俺虽然不是NJU学僧，但老师发的就是NJU的材料。羡慕NJU！</p><p>若涉嫌侵权请联系我删除，谢谢！</p></blockquote><h1 id="实验过程中的教训" tabindex="-1"><a class="header-anchor" href="#实验过程中的教训" aria-hidden="true">#</a> 实验过程中的教训</h1><h2 id="flex" tabindex="-1"><a class="header-anchor" href="#flex" aria-hidden="true">#</a> Flex</h2><p>**符号|左右别有空格！**否则会报<code>unrecognized rule</code>。譬如：</p><div class="language-flex line-numbers-mode" data-ext="flex"><pre class="language-flex"><code>RELOP &quot;&gt;&quot; | &quot;&lt;&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;==&quot; | &quot;!=&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>RELOP &quot;&gt;&quot;|&quot;&lt;&quot;|&quot;&gt;=&quot;|&quot;&lt;=&quot;|&quot;==&quot;|&quot;!=&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>**出错位置在报错行前一行找！**譬如某行报<code>unrecognized rule</code>，去找对应行的规则，重点关注对应行的规则上一行。</p><p>看群里说如果自定义了<code>yyerror</code>，需要加外部声明<code>extern xxx</code>不然会报<code>warning</code></p><p>在Bison源代码中用<code>%union</code>和<code>%type&lt;&gt;</code>声明完类型后，我们就可以在Flex源代码中赋值。注意：此时不能直接是<code>yylval=xxx</code>，而应该是<code>yylval.type_name=xxxx</code>！！</p><p>需要为空白符号专门设置规则！不然会报错的...</p><h2 id="bison" tabindex="-1"><a class="header-anchor" href="#bison" aria-hidden="true">#</a> Bison</h2><p>需要在Bison（而不是Flex）的源文件开头添加<code>%locations</code>以使用<code>yylloc</code>等变量！</p><p>关于<code>-</code>的优先级处理：<code>-</code>既可以是减号，也可以是取负，优先级和结合性都不一样。</p><h1 id="flex-1" tabindex="-1"><a class="header-anchor" href="#flex-1" aria-hidden="true">#</a> Flex</h1><h2 id="cheatsheet" tabindex="-1"><a class="header-anchor" href="#cheatsheet" aria-hidden="true">#</a> CheatSheet</h2><p>Flex库函数<code>yylex()</code>，该函数的作用就是<strong>读取</strong>输入文件中的一个<strong>词法单元</strong>。</p><p>变量 <code>yyin</code>是Flex内部使用的一个变量，表示<strong>输入文件的文件指针</strong>，如果我们不去设置它，那么Flex 会将它自动设置为<code>stdin</code>（即标准输入，通常连接到键盘）。</p><p>变量<code>yytext</code>的类型为<code>char*</code>，它是Flex为我们提供的一个变量，里面保存了<strong>当前词法单元所对应的词素</strong>。</p><p>若要自定义不匹配时的行为，在所有规则的<strong>最后</strong>加上一条<code>.</code>（即匹配任何输入）规则，然后在其对应的action部分书写你想要的行为即可。</p><p><code>yyleng</code>是Flex为我们提供的变量，你可以将其理解为<code>strlen(yytext)</code>。</p><p><code>yyrestart(f)</code>函数是Flex提供的库函数，它可以让Flex将其输入文件的文件指针**<code>yyin</code>设置为<code>f</code><strong>（当然你也可以像前面一样手动设置令<code>yyin = f</code>）并</strong>重新初始化该文件指针**，令其指向输入文件的开头。</p><p>Flex内部提供了类似记录<strong>行号</strong>的变量，叫做<code>yylineno</code>。想要用它，要在Flex源代码的定义部分加入语句<code>%option yylineno</code>。但请注意：如果在词法分析过程中调用<code>yyrestart()</code>函数读取另一个输入文件时，它却<strong>不会重新被初始化</strong>，因此我们需要<strong>自行添加初始化语句</strong><code>yylineno= 1</code>。</p><p>Flex库函数<code>input()</code>可以从当前的输入文件中<strong>读入一个字符</strong>（相当于是<strong>直接挪动文件指针</strong>而<strong>不经过词法分析</strong>）。</p><p>Flex库函数<code>unput(char c)</code>可以将<strong>指定的字符放回输入缓冲区</strong>中。</p><p>Flex库函数<code>yyless(int n)</code>可以将刚从输入缓冲区中读取的<code>yyleng−n</code>个字符放回到输入缓冲区中（反向理解：保留前面的<code>n</code>个字符，将剩下的后面的字符全部放回缓冲区）。</p><p>Flex库函数<code>yymore()</code>可以告诉Flex保留当前词素，并在下一个词法单元被识别出来之后将下一个词素连接到当前词素的后面。</p><p>Flex宏<code>REJECT</code><strong>将<code>yytext</code>放回输入之内</strong>，然后去<strong>试图匹配当前规则之后的那些规则</strong>。</p><p><code>yylval</code>是Flex的内部变量，表示当前<strong>词法单元所对应的属性值</strong>。</p><p><code>yylloc</code>是Flex的内置变量，表示当前词法单元所对应的位置信息。</p><p><code>YY_USER_ACTION</code>宏表示在执行每一个动作之前需要先被执行的一段代码，默认为空。</p><h2 id="词法分析概述" tabindex="-1"><a class="header-anchor" href="#词法分析概述" aria-hidden="true">#</a> 词法分析概述</h2><p>英文比较容易断词：相邻的英文字母一定属于同一个词，而字母与字母之间插入任何非字母的字符（如空格、运算符等）就可以将一个词断成两个词。</p><h2 id="gnu-flex介绍" tabindex="-1"><a class="header-anchor" href="#gnu-flex介绍" aria-hidden="true">#</a> GNU Flex介绍</h2><p>假设这写好的代码名为<code>lexical.l</code>。随后，我们使用Flex对该代码进行编译：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>flex lexical.l
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译好的结果会保存在当前目录下的<code>lex.yy.c</code>文件中。</p><p>这份源代码里有一个函数叫做<code>yylex()</code>，该函数的作用就是<strong>读取</strong>输入文件中的一个<strong>词法单元</strong>。</p><p>变量 <code>yyin</code>是Flex内部使用的一个变量，表示<strong>输入文件的文件指针</strong>，如果我们不去设置它，那么Flex 会将它自动设置为<code>stdin</code>（即标准输入，通常连接到键盘）。</p><blockquote><p>注意，如果你将<code>main</code>函数独立设为一个文件，则需要声明<code>yyin</code>为外部变量：<code>extern FILE* yyin</code>。</p></blockquote><p>然后编译这两个C源文件。我们将输出程序命名为<code>scanner</code>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc main.c lex.yy.c <span class="token parameter variable">-lfl</span> <span class="token parameter variable">-o</span> scanner
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中<code>-lfl</code>参数指定要使用Flex的库文件，不能少。</p><p>想要对一个测试文件<code>test.cmm</code>进行词法分析，仅需：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>./scanner test.cmm
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="编写源代码" tabindex="-1"><a class="header-anchor" href="#编写源代码" aria-hidden="true">#</a> 编写源代码</h2><p>Flex源代码文件包括三个部分，由“%%”隔开，如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{definitions}
%%
{rules}
%%
{user subroutines}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一部分为<strong>定义部分</strong>，实际上就是给某些后面可能经常用到的正则表达式取一个别名，定义部分的格式一般为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>name definition
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>譬如：<code>letter [a-zA-Z]</code></p><p>在规则中使用定义过的正则表达式的别名的话，需要为别名套上<code>{}</code>。</p><p>第二部分为<strong>规则部分</strong>，它由正则表达式和相应的响应函数组成，其格式为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>pattern {action}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中<code>pattern</code>为正则表达式，<code>action</code>为将要进行的具体操作，这些操作可以用一段C代码表示。</p><p>譬如：<code>{letter}+ {printf(&quot;%s&quot;, yytext);}</code></p><p>其中变量<code>yytext</code>的类型为<code>char*</code>，它是Flex为我们提供的一个变量，里面保存了<strong>当前词法单元所对应的词素</strong>。</p><p>若要自定义不匹配时的行为，在所有规则的<strong>最后</strong>加上一条<code>.</code>（即匹配任何输入）规则，然后在其对应的action部分书写你想要的行为即可。</p><p>第三部分为<strong>用户自定义代码部分</strong>。这部分代码会被原封不动地拷贝到<code>lex.yy.c</code>中，以方便用户自定义所需要执行的函数。如果用户想要<strong>对自定义代码部分所用到的变量、函数或者头文件进行声明</strong>，可以在前面的<strong>定义部分</strong>（即Flex源代码文件的第一部分）之前使用<code>%{</code>和<code>%}</code>符号将要声明的内容添加进去。被<code>%{</code>和<code>%}</code>所包围的内容也会一并拷贝到<code>lex.yy.c</code>的最前面。</p><blockquote><p>注意是<code>%{</code>和<code>%}</code>，而不是<code>}%</code>，否则用flex时会报<code>premature EOF</code>错误</p></blockquote><p><code>yyleng</code>是Flex为我们提供的变量，你可以将其理解为<code>strlen(yytext)</code>。</p><p>譬如：<code>{letter}+ { words++; chars+= yyleng; }</code></p><p><code>yyrestart(f)</code>函数是Flex提供的库函数，它可以让Flex将其输入文件的文件指针**<code>yyin</code>设置为<code>f</code><strong>（当然你也可以像前面一样手动设置令<code>yyin = f</code>）并</strong>重新初始化该文件指针**，令其指向输入文件的开头。</p><p>譬如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>FILE <span class="token operator">*</span>f <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">&quot;r&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">yyrestart</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">yylex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="书写正则表达式" tabindex="-1"><a class="header-anchor" href="#书写正则表达式" aria-hidden="true">#</a> 书写正则表达式</h2><ul><li>符号<code>[</code>和<code>]</code>共同匹配一个字符类，即方括号之内只要有一个字符被匹配上了，那么被方括号括起来的整个表达式都被匹配上了。</li><li>符号<code>&quot;</code>（英文引号）将<strong>逐字匹配被引起来的内容</strong>（即<strong>无视</strong>各种<strong>特殊符号及转义字符</strong>）。例如，表达式<code>&quot;...&quot;</code>就表示三个点而不表示三个除换行符以外的任意字符。</li><li>符号<code>/</code>会查看输入字符的上下文，例如，<code>x/y</code>识别<code>x</code>仅当在输入文件中<code>x</code>之后紧跟着<code>y</code>，<code>0/1</code>可以匹配输入串01中的0但不匹配输入串02中的0。</li></ul><h2 id="高级特性" tabindex="-1"><a class="header-anchor" href="#高级特性" aria-hidden="true">#</a> 高级特性</h2><p>在写编译器程序的过程中，经常会需要记录<strong>行号</strong>，可以自己定义某个变量，例如<code>lines</code>，每当识别出<code>\n</code>我们就让<code>lines = lines + 1</code>。</p><p>Flex内部提供了类似记录<strong>行号</strong>的变量，叫做<code>yylineno</code>。想要用它，要在Flex源代码的定义部分加入语句<code>%option yylineno</code>。但请注意：如果在词法分析过程中调用<code>yyrestart()</code>函数读取另一个输入文件时，它却<strong>不会重新被初始化</strong>，因此我们需要<strong>自行添加初始化语句</strong><code>yylineno= 1</code>。</p><blockquote><p>关于输入缓冲区的部分，略了。</p></blockquote><p>Flex库函数<code>input()</code>可以从当前的输入文件中<strong>读入一个字符</strong>（相当于是<strong>直接挪动文件指针</strong>而<strong>不经过词法分析</strong>）。</p><p>譬如：实现在输入文件中发现双斜线<code>//</code>后，将从当前字符开始一直到行尾的所有字符全部丢弃掉（即忽略注释）：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">%</span><span class="token operator">%</span>
<span class="token string">&quot;//&quot;</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token char">&#39;\n&#39;</span><span class="token punctuation">)</span> c <span class="token operator">=</span> <span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Flex库函数<code>unput(char c)</code>可以将<strong>指定的字符放回输入缓冲区</strong>中。譬如：当在输入文件中遇到字符串<code>BUFFER_LEN</code>时，下面这段代码将该宏所对应的内容（<code>1024</code>）放回输入缓冲区：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">macro_contents</span><span class="token punctuation">(</span><span class="token string">&quot;BUFFER_LEN&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p = “1024”</span>
<span class="token keyword">char</span><span class="token operator">*</span> q <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>q <span class="token operator">&gt;</span> p<span class="token punctuation">)</span> <span class="token function">unput</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">--</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>透过上面的示例代码，可以看到是<strong>逆序放回缓冲区</strong>的。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[原本的待读入内容]
[4原本的待读入内容]
[24原本的待读入内容]
[024原本的待读入内容]
[1024原本的待读入内容]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>Flex库函数<code>yyless(int n)</code>可以将刚从输入缓冲区中读取的<code>yyleng−n</code>个字符放回到输入缓冲区中（反向理解：保留前面的<code>n</code>个字符，将剩下的后面的字符全部放回缓冲区）。函数<code>yymore()</code>可以告诉Flex保留当前词素，并在下一个词法单元被识别出来之后将下一个词素连接到当前词素的后面。配合使用<code>yyless()</code>和<code>yymore()</code>可以方便地处理那些边界难以界定的模式。</p><p>例如，我们在为字符串常量书写正则表达式时，往往会写成由一对双引号引起来的所有内容<code>\&quot;[^\&quot;]*\&quot;</code>，但有时候<strong>被双引号引起来的内容</strong>里面<strong>也可能出现跟在转义符号之后的双引号</strong>，例如<code>&quot;This is an \&quot;example\&quot;&quot;</code>。那么如何使用Flex处理这种情况呢？方法之一就是借助于<code>yyless</code>和<code>yymore</code>：</p><div class="language-flex line-numbers-mode" data-ext="flex"><pre class="language-flex"><code>{\&quot;[^\&quot;]*\&quot;} {
    if(yytext[yyleng-2] == &#39;\\&#39;) //如果倒第二个字符是斜杠，说明是转义字符
    {
        yyless(yyleng-1); //把&quot;放回缓冲区
        yymore();//下面识别出来的词素拼在当前词素后面
    } else{
        //这把是真处理完了，该咋整咋整
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Flex宏<code>REJECT</code>可以帮助我们识别那些互相重叠的模式。当我们执行<code>REJECT</code>之后，Flex会进行一系列的操作，这些操作的结果相当于<strong>将<code>yytext</code>放回输入之内</strong>，然后去<strong>试图匹配当前规则之后的那些规则</strong>。</p><p>譬如：统计输入文件中所有的<code>pink</code>、<code>ink</code>和<code>pin</code>出现的个数，即使这三个单词之间互有重叠。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>pink <span class="token punctuation">{</span>pink<span class="token operator">++</span><span class="token punctuation">;</span> REJECT<span class="token punctuation">;</span><span class="token punctuation">}</span>
ink <span class="token punctuation">{</span>ink<span class="token operator">++</span><span class="token punctuation">;</span> REJECT<span class="token punctuation">;</span><span class="token punctuation">}</span>
pin <span class="token punctuation">{</span>pin<span class="token operator">++</span><span class="token punctuation">;</span> REJECT<span class="token punctuation">;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="bison-1" tabindex="-1"><a class="header-anchor" href="#bison-1" aria-hidden="true">#</a> Bison</h1><h2 id="语法分析概述" tabindex="-1"><a class="header-anchor" href="#语法分析概述" aria-hidden="true">#</a> 语法分析概述</h2><p>语法分析程序的主要任务是<strong>读入词法单元流</strong>、判断输入程序是否匹配程序设计语言的语法规范，并在匹配规范的情况下<strong>构建起输入程序的静态结构</strong>。</p><p>Bison所生成的语法分析程序采用了自底向上的LALR(1)分析技术。</p><h2 id="gnu-bison介绍" tabindex="-1"><a class="header-anchor" href="#gnu-bison介绍" aria-hidden="true">#</a> GNU Bison介绍</h2><p>假设这份写好的Bison源代码名为<code>syntax.y</code>。随后，我们使用Bison对这份代码进行编译：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bison syntax.y
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译好的结果会保存在当前目录下的<code>syntax.yy.c</code>文件中。打开这个文件你就会发现，该文件本质上就是一份C语言的源代码。</p><p>这个文件中有一个函数<code>yyparse()</code>，该函数的作用就是对输入文件进行语法分析，如果分析成功没有错误则返回0，否则返回非0。</p><p>Bison通过<code>yylex()</code>来获得词法单元，这个函数由用户为它提供。但因为我们之前已经使用Flex生成了一个<code>yylex()</code>函数，让Bison使用Flex生成的<code>yylex()</code>函数即可。</p><p>仍以Bison源代码文件<code>syntax.y</code>为例。首先，<strong>为了能够使用Flex中的各种函数</strong>，需要<strong>在Bison源代码中引用</strong><code>lex.yy.c</code>：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;lex.yy.c&quot;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>随后在使用Bison编译这份源代码时，我们需要加上“-d”参数：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bison <span class="token parameter variable">-d</span> syntax.y
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个参数的含义是，将编译的结果分拆成<code>syntax.tab.c</code>和<code>syntax.tab.h</code>两个文件，其中<code>.h</code>文 件里包含着一些<strong>词法单元的类型定义</strong>之类的内容。</p><p>得到这个.h文件之后，下一步是修改我们的Flex源代码<code>lexical.l</code>，增加对<code>syntax.tab.h</code>的引用，并且让Flex源代码中规则部分的<strong>每一条action都返回相应的词法单元</strong>。（相当于是Bison给Flex提要求：老弟，过会你把词法单元给我的时候，按我能识别的方式来啊！）</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">%</span><span class="token punctuation">{</span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;syntax.tab.h&quot;</span></span>
  …
<span class="token operator">%</span><span class="token punctuation">}</span>
…
<span class="token operator">%</span><span class="token operator">%</span>
<span class="token string">&quot;+&quot;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> PLUS<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token string">&quot;-&quot;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> SUB<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token string">&quot;&amp;&amp;&quot;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> AND<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token string">&quot;||&quot;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> OR<span class="token punctuation">;</span> <span class="token punctuation">}</span>
…
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，返回值PLUS和SUB等都是在Bison源代码中定义过的词法单元（也就是在<code>syntax.tab.h</code>）里面。由于我们刚刚修改了<code>lexical.l</code>，需要重新将它编译出来：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>flex lexical.l
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来是重写我们的<code>main</code>函数。由于Bison会在需要时<strong>自动调用<code>yylex()</code></strong>，我们在main函数中也就不需要调用它了。不过，Bison是<strong>不会自己调用<code>yyparse()</code>和<code>yyrestart()</code>的</strong>，因此这两个函数仍需要我们在main函数中显式地进行调用：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  FILE<span class="token operator">*</span> f <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">&quot;r&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">yyrestart</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">yyparse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们有了三个C语言源代码文件：<code>main.c</code>、<code>lex.yy.c</code>以及<code>syntax.tab.c</code>，其中<code>lex.yy.c</code>已经被<code>syntax.tab.c</code>引用了，因此我们最后要做的就是把<code>main.c</code>和<code>syntax.tab.c</code>放到一起进行编译：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc main.c syntax.tab.c <span class="token parameter variable">-lfl</span> <span class="token parameter variable">-ly</span> <span class="token parameter variable">-o</span> parser
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>其中“-lfl”不要省略，否则GCC会因缺少库函数而报错，但“-ly”这里一般情况下可以 省略。如果加上“-ly”参数，编译报错，可以安装libbison-dev依赖库。</p></blockquote><p>现在我们可以使用这个parser程序进行语法分析了。例如，想要对一个输入文件<code>test.cmm</code>进行语法分析，只需要在命令行输入：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>./parser test.cmm
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="编写源代码-1" tabindex="-1"><a class="header-anchor" href="#编写源代码-1" aria-hidden="true">#</a> 编写源代码</h2><p>Bison源代码也分为三个部分，其作用与Flex源代码大致相同。</p><p>第一部分是<strong>定义部分</strong>，所有<strong>词法单元的定义</strong>都可以放到这里；</p><p>第二部分是<strong>规则部分</strong>，其中包括具体的语法和相应的语义动作；</p><p>第三部分是<strong>用户函数部分</strong>，这部分的源代码会被原封不动地拷贝到<code>syntax.tab.c</code>中，以方便用户自定义所需要的函数（<code>main</code>函数也可以写在这里，不过不推荐这么做）。</p><p>值得一提的是，如果用户想要对这部分所用到的变量、函数或者头文件进行声明，可以在定义部分（也就是Bison源代码的第一部分）之前使用“%{”和“%}”符号将要声明的内容添加进去。被“%{”和“%}”所包围的内容也会被一并拷贝到<code>syntax.tab.c</code>的最前面。</p><p>给定语法：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Calc → ε
| Exp
Exp → Factor
| Exp ADD Factor
| Exp SUB Factor
Factor → Term
| Factor MUL Term
| Factor DIV Term
Term → INT
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编写Bison源代码</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">%</span><span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token operator">%</span><span class="token punctuation">}</span>

<span class="token comment">/* declared tokens */</span>
<span class="token comment">/* 对终结符进行了声明 */</span>
<span class="token operator">%</span>token INT
<span class="token operator">%</span>token ADD SUB MUL DIV

<span class="token operator">%</span><span class="token operator">%</span>
Calc <span class="token operator">:</span> <span class="token comment">/* empty */</span>
  <span class="token operator">|</span> Exp <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;= %d\n&quot;</span><span class="token punctuation">,</span> $<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">;</span>
Exp <span class="token operator">:</span> Factor
  <span class="token operator">|</span> Exp ADD Factor <span class="token punctuation">{</span> $$ <span class="token operator">=</span> $<span class="token number">1</span> <span class="token operator">+</span> $<span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> Exp SUB Factor <span class="token punctuation">{</span> $$ <span class="token operator">=</span> $<span class="token number">1</span> <span class="token operator">-</span> $<span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">;</span>
Factor <span class="token operator">:</span> Term
  <span class="token operator">|</span> Factor MUL Term <span class="token punctuation">{</span> $$ <span class="token operator">=</span> $<span class="token number">1</span> <span class="token operator">*</span> $<span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token operator">|</span> Factor DIV Term <span class="token punctuation">{</span> $$ <span class="token operator">=</span> $<span class="token number">1</span> <span class="token operator">/</span> $<span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">;</span>
Term <span class="token operator">:</span> INT
  <span class="token punctuation">;</span>
<span class="token operator">%</span><span class="token operator">%</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;lex.yy.c&quot;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">yyparse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">yyerror</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">&quot;error: %s\n&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>几个值得注意的点：</p><ul><li>以<code>%token</code>开头的是**词法单元（终结符）**的定义</li><li>未被定义为<code>%token</code>的符号都会被看作非终结符，要求必须在任意产生式的<strong>左边</strong>至少出现一次</li><li><strong>第一个产生式左边的非终结符</strong>默认为<strong>初始符号</strong></li><li>产生式里的箭头用冒号<code>:</code>表示，一组产生式与另一组之间以分号<code>;</code>隔开。</li><li>终结符和非终结符都各自对应一个属性值： <ul><li>产生式<strong>左边的非终结符</strong>对应的属性值用<code>$$</code>表示</li><li>产生式<strong>右边的文法符号</strong>对应的属性值从左到右的顺序依次对应为<code>$1</code>、<code>$2</code>、<code>$3</code>等</li></ul></li><li>产生式的最后可以添加一组以花括号“{”和“}”括起来的语义动作，如果不明确指定语义动作，Bison将采用默认的语义动作<code>{ $$ = $1 }</code></li><li><code>yyerror()</code>函数会在你的语法分析程序<strong>每发现一个语法错误时被调用</strong>，默认情况下<code>yyerror()</code>只会将传入的字符串参数打印到标准错误输出上，可以自定义。</li></ul><p>非终结符的属性值都可以通过它所产生的那些终结符或者非终结符的属性值计算出来，但是<strong>终结符本身的属性值该如何得到</strong>呢？</p><p>答案是：在<code>yylex()</code>函数中得到。因而我们要修改前面的Flex源代码（假设在我们的Flex源代码中，INT词法单元对应着一个数字串）：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>…
digit <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">%</span><span class="token operator">%</span>
<span class="token punctuation">{</span>digit<span class="token punctuation">}</span><span class="token operator">*</span> <span class="token punctuation">{</span>
  yylval <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>yytext<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> INT<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
…
<span class="token operator">%</span><span class="token operator">%</span>
…
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>yylval</code>是Flex的内部变量，表示当前<strong>词法单元所对应的属性值</strong>。我们只需将该变量的值赋成<code>atoi(yytext)</code>，就可以将词法单元INT的属性值设置为它所对应的整数值了。</p><h2 id="属性值的类型" tabindex="-1"><a class="header-anchor" href="#属性值的类型" aria-hidden="true">#</a> 属性值的类型</h2><p>在我们构建语法树的过程中，我们希望<strong>不同的符号对应的属性值</strong>能有<strong>不同的类型</strong>。</p><p>方法一是对宏<code>YYSTYPE</code>进行重定义。Bison里会<strong>默认所有属性值的类型以及变量<code>yylval</code>的类型</strong>都是<code>YYSTYPE</code>，默认情况下<code>YYSTYPE</code>被定义为<code>int</code>。</p><p>方法一最大的缺点是把所有的变量属性值的类型都给他变了，但我们想要的是不同属性值能有不同的类型，不管。</p><p>方法二要点如下：</p><ul><li>首先，我们在定义部分的开头使用<code>%union{…}</code>将所有可能的类型都包含进去</li><li>对于<strong>词法单元</strong>，在<code>%token</code>部分我们使用一对尖括号<code>&lt;&gt;</code>把需要确定属性值类型的每个词法单元所对应的类型括起来</li><li>对于<strong>非终结符</strong>，我们使用<code>%type</code>加上尖括号的办法确定它们的类型</li><li>当所有需要确定类型的符号的类型都被定下来之后，规则部分里的<code>$$</code>、<code>$1</code>等就自动地带有了相应的类型，不再需要我们显示地为其指定类型了。</li></ul><p>譬如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">%</span><span class="token punctuation">{</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token operator">%</span><span class="token punctuation">}</span>

<span class="token comment">/* declared types */</span>
<span class="token operator">%</span><span class="token keyword">union</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> type_int<span class="token punctuation">;</span>
  <span class="token keyword">float</span> type_float<span class="token punctuation">;</span>
  <span class="token keyword">double</span> type_double<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* declared tokens */</span>
<span class="token operator">%</span>token <span class="token operator">&lt;</span>type_int<span class="token operator">&gt;</span> INT
<span class="token operator">%</span>token <span class="token operator">&lt;</span>type_float<span class="token operator">&gt;</span> FLOAT
<span class="token operator">%</span>token ADD SUB MUL DIV

<span class="token comment">/* declared non-terminals */</span>
<span class="token operator">%</span>type <span class="token operator">&lt;</span>type_double<span class="token operator">&gt;</span> Exp Factor Term

<span class="token operator">%</span><span class="token operator">%</span>
Calc <span class="token operator">:</span> <span class="token comment">/* empty */</span>
  <span class="token operator">|</span> Exp <span class="token punctuation">{</span> <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">=</span> <span class="token operator">%</span>lf\n<span class="token punctuation">,</span> $<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="语法单元的位置" tabindex="-1"><a class="header-anchor" href="#语法单元的位置" aria-hidden="true">#</a> 语法单元的位置</h2><p>Bison中<strong>每个语法单元</strong>不仅都对应了一个属性值，还<strong>对应了一个位置信息</strong>，在语义动作中这些位置信息同样可以使用<code>@$</code>、<code>@1</code>、<code>@2</code>等进行引用。</p><p>位置信息的数据类型是一个<code>YYLTYPE</code>，其默认的定义是：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">YYLTYPE</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> first_line<span class="token punctuation">;</span>
  <span class="token keyword">int</span> first_column<span class="token punctuation">;</span>
  <span class="token keyword">int</span> last_line<span class="token punctuation">;</span>
  <span class="token keyword">int</span> last_column<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中的<code>first_line</code>和<code>first_column</code>分别是该语法单元对应的<strong>第一个词素出现的行号和列号</strong>，而<code>last_line</code>和<code>last_column</code>分别是该语法单元对应的最后一个词素出现的行号和列号。</p><p>但注意，如果直接引用<code>@1</code>、<code>@2</code>等将每个语法单元的<code>first_line</code>打印出来，你会发现打印出来的行号全都是1。Bison并不会主动替我们维护这些位置信息，我们需要<strong>在Flex源代码文件中自行维护</strong>。</p><p><code>yylloc</code>是Flex的内置变量，表示当前词法单元所对应的位置信息；<code>YY_USER_ACTION</code>宏表示在执行每一个动作之前需要先被执行的一段代码，默认为空，但可改正。<code>yycolumn</code>是自己定义的变量。</p><p>除此之外，最后还要在发现了换行符之后对变量<code>yycolumn</code>进行复位。</p><blockquote><p>注意：<strong>bison的源文件开头</strong>一定要加上<code>%locations</code></p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">%</span>locations
…
<span class="token operator">%</span><span class="token punctuation">{</span>
<span class="token comment">/* 此处省略#include部分 */</span>
<span class="token keyword">int</span> yycolumn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">YY_USER_ACTION</span> <span class="token punctuation">\</span>
  <span class="token expression">yylloc<span class="token punctuation">.</span>first_line <span class="token operator">=</span> yylloc<span class="token punctuation">.</span>last_line <span class="token operator">=</span> yylineno<span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
  <span class="token expression">yylloc<span class="token punctuation">.</span>first_column <span class="token operator">=</span> yycolumn<span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
  <span class="token expression">yylloc<span class="token punctuation">.</span>last_column <span class="token operator">=</span> yycolumn <span class="token operator">+</span> yyleng <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
  <span class="token expression">yycolumn <span class="token operator">+=</span> yyleng<span class="token punctuation">;</span></span></span>
<span class="token operator">%</span><span class="token punctuation">}</span>
<span class="token operator">%</span><span class="token operator">%</span>
\n <span class="token punctuation">{</span> yycolumn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token operator">%</span><span class="token operator">%</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="错误恢复" tabindex="-1"><a class="header-anchor" href="#错误恢复" aria-hidden="true">#</a> 错误恢复</h2><blockquote><p>突然想到一个很好玩的事情，既然每行只会出现一个错误，为什么不把换行符当作兜底符号呢（笑）</p></blockquote><p>为啥要错误恢复？关键在于“<strong>恢复</strong>”二字。将导致错误的词法成分算到某个语法成分里，使语法分析能够正常的分析下去，这才是错误恢复的目的，也是我们下面插<code>error</code>的目的。</p><blockquote><p>请牢记：语法分析的终结符是词法单元，如果语法分析出错了，说明是当前的词法单元不对，而不是输入串中的最前面的字符不对！</p></blockquote><p>由于本实验要识别具体的Type B类型，所以还要了解Bison错误恢复的机制。</p><p>课程上我们说“恐慌模式”错误恢复的本质是<strong>跳过出错的语法成分</strong>，<strong>继续分析</strong>该<strong>出错部分之后的字符</strong>。<code>error</code>符号便是代表了<strong>出错的语法成分</strong>。产生式中<code>error</code>后面的语法成分决定了<strong>出错部分之后的字符</strong>（<code>error</code>后面的语法成分的<code>FIRST</code>集合）。</p><p>譬如<code>int a[5,,,3]</code>，使用产生式<code>VarDec -&gt; VarDec LB INT RB;</code>，有规约过程：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>VarDec =&gt; VarDec LB INT RB
       =&gt; VarDec LB INT RB LB INT RB
                        ^^
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相当于是当前栈中已有<code>VarDec LB INT[栈顶]</code>，下面期待来一个<code>RB</code>，没想到来一个<code>COMMA</code>，在分析表找不到对应的规则，于是报错。</p><p>假设有产生式<code>VarDec -&gt; VarDec LB INT error RB;</code>，那么<code>INT</code>便是一个可移入<code>ERROR</code>的状态。接着便会抛弃输入符号中的<code>,,,</code>直到遇到<code>RB</code>为止，<code>a[5,,,3]</code>最终被规约为了<code>VarDec</code>，继续后续的分析。</p><blockquote><p>简而言之，发生错误时，将<code>error</code>放在输入串的开头，不断地弹出状态/符号栈，看谁后面能移入<code>error</code>，移入<code>error</code>后，便开始丢弃输入串中字符，直至能有字符能跟在<code>error</code>后面为止。</p></blockquote><p>那么带有<code>error</code>的产生式的动作怎么写？</p><p>首先应调用<code>yyerror</code>输出带有<code>error</code>的产生式的对应错误成分。</p><p>最后调用<code>yyerrok;</code>，这是因为：我们知道在<code>error</code>之后能成功移入三个符号，才继续正常的语法分析；但像这个产生式<code>VarDec -&gt; VarDec LB INT error RB;</code>，我们期望当成功移入<code>RB</code>这<strong>一个符号</strong>就可以继续进行语法分析的话，此时要使用<code>yyerrok;</code>来“说明”这个情况。</p><p>例如：</p><div class="language-bison line-numbers-mode" data-ext="bison"><pre class="language-bison"><code>VarDec <span class="token operator">:</span> VarDec error <span class="token punctuation">{</span><span class="token function">yyerror</span><span class="token punctuation">(</span><span class="token string">&quot;Missing \&quot;]\&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>yyerrok<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>按照上面的思路，加了<code>error</code>后，却没有输出我们指定的错误信息，此时应该考虑：出错涉及的产生式是不是还没有加入<code>error</code>。譬如我们上面举的例子<code>int a[5,,,3]</code>，会对应到<code>VarDec</code>这个产生式。但是对于<code>a[5,,,3] = 3;</code>，如果要识别它识别缺少<code>]</code>的情况，我们还要对<code>Exp-&gt;Exp RB Exp LB</code>这个产生式添加<code>error</code>才行。</p><blockquote><p>别问我怎么知道的，问就是开Debug看自动机是怎么运转的</p></blockquote><p>那么在实验当中要考虑哪些潜在的语法错误呢？</p><p>毕竟<code>error</code>代表的是会出错的语法单元。不妨<strong>先看看哪些语法单元会出错</strong>吧！处理以这个语法单元为左部的产生式后，就不用在顶层担心这个语法单元会出错了。有一种<strong>自底向上</strong>的感觉啊！</p><ul><li>括号的匹配：包括不限于<code>[ ]</code>、<code>( )</code>、<code>{ }</code></li><li>结束符：<code>;</code></li><li>表达式：对<code>Exp -&gt; xxx</code>一系列式子进行处理后，就没必要在上层有<code>Exp</code>的地方进行处理了。</li><li><code>xxxList</code>不用考虑，如果<code>xxxList</code>出问题，肯定是<code>xxx</code>出问题了。</li></ul><p>实验过程中出现了以下问题：</p><p>问题一：加入<code>error</code>式后，产生了移入-规约冲突；譬如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ExtDef : Specifier ExtDecList error {yyerror(&quot;Missing \&quot;;\&quot;.&quot;);yyerrok;}
  | Specifier error {yyerror(&quot;Missing \&quot;;\&quot;.&quot;);yyerrok;}
  ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>乍一看没啥问题，但是，<code>ExtDecList</code>也是会导出<code>error</code>的唷！</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ExtDecList : VarDec;
VarDec : VarDec error;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>截取自动机的状态看一看</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>State 18

   10 ExtDecList: VarDec • //重点在这一行
   11           | VarDec • COMMA ExtDecList
   20 VarDec: VarDec • LB INT RB
   21       | VarDec • LB error RB
   22       | VarDec • error  //重点在这一行

    error  shift, and go to state 24
    COMMA  shift, and go to state 25
    LB     shift, and go to state 26

    error  [reduce using rule 10 (ExtDecList)]
    SEMI   reduce using rule 10 (ExtDecList)
 
 rule 10: ExtDecList: VarDec
              | VarDec COMMA ExtDecList
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个活前缀可能对应着不同产生式的不同的识别状态。譬如对于活前缀<code>VarDec ·</code>，可以是<code>ExtDecList: VarDec •</code>，也可以是<code>VarDec: VarDec • error</code>。如果是在<code>VarDec</code>后面出现了错，即跟在<code>VarDec</code>后面的语法单元和当前状态在分析表中没有对应条目时，可能会“弹出规则”，将<code>VarDec</code>还原成<code>ExtDecList</code>，也可能会根据<code>VarDec: VarDec • error</code>，移入<code>error</code>。</p><p>问题二：是<code>error SEMI</code>更好，还是单纯的<code>error</code>更好？</p><p>譬如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Specifier ExtDecList SEMI {$$ = createNode(&quot;ExtDef&quot;, Others, NULL, @$.first_line, $1, NULL); $1-&gt;nextsibling=$2; $2-&gt;nextsibling=$3;}
①: Specifier ExtDecList error SEMI {yyerror(&quot;Missing \&quot;;\&quot;.&quot;);yyerrok;}
②: Specifier ExtDecList error {yyerror(&quot;Missing \&quot;;\&quot;.&quot;);yyerrok;}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我个人认为不加<code>SEMI</code>有助于更快的恢复。因为你本来就是缺分号，如果用①的话却还希望找到分号，势必会丢掉更多的输入单元。（输入文件中可能包含一个或者多个错误（<strong>但输入文件的同一 行中保证不出现多个错误</strong>），如果丢符号丢到下一行那就寄了）但我的这个观点好像和指导书有冲突...</p><p>出现语法错误的根源是词法单元串不匹配。个人感觉应该放在底层的产生式中，即词法单元旁边为妙。</p><p>两个都上行不行呢？答案是不行。譬如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>State 119

   71 Exp: ID LP Args error • RP
   72    | ID LP Args error •

    RP  shift, and go to state 126

    RP        [reduce using rule 72 (Exp)]
    $default  reduce using rule 72 (Exp)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果<code>error</code>在产生式中间，很好理解。<strong>如果<code>error</code>在一个产生式的开头</strong>，会意味着什么呢？或者说<code>error</code>可以处在一个产生式的开头吗？应该是可以放在开头的，可以理解为为某个语法成分“兜底”？</p><p>譬如：<code>Stmt → error SEMI</code>，我这个<code>Stmt</code>确实是出错了，错哪里我是不知道，但在后续的分析中你得把我看成是<code>Stmt</code>！</p><p>是不是可以这样理解：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>某状态：
StmtList → Stmt •StmtList
StmtList → •Stmt StmtList
Stmt → •error SEMI
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>开头是<code>error</code>，代表着其左部是在另外一个产生式右部的某个部分的。</p><p>产生式最后 能不能是<code>error</code>呢？如果产生式最后是<code>error</code>，意味着不管下面是啥字符，直接进行规约。譬如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Exp LB error %prec LOW_PRIORITY {yyerror(&quot;Missing \&quot;]\&quot;&quot;); yyerrok;}
Exp LB error RB {yyerror(&quot;Wrong in Expression.&quot;); yyerrok;}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于<code>a[=]</code>，读到<code>=</code>时出错。因为引起<code>error</code>的语法单元（<code>=</code>）还没有“移入”，只是“读到”了。当<code>error</code>入栈后，读到的还是引起<code>error</code>的语法单元（<code>=</code>），并不是<code>RB</code>，所以直接规约了，即便后面是有<code>RB</code>的。</p><p>从<code>Exp</code>开始搞起。牢记：<code>error</code>代表了出错的语法成分，是我们想要“跳过”的语法成分。</p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/jielahou/jielahou-blog/edit/main/docs/compile/flex_bison.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><!----></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: jielahou@gmail.com">jielahou</span><!--]--><!--]--></div></footer><!----><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"></div><div class="copyright">Copyright © 2023 jielahou</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-04f92937.js" defer></script>
  </body>
</html>
