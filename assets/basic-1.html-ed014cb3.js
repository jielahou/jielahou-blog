import{_ as e,W as n,X as i,$ as l,Y as s,Z as a}from"./framework-f7711481.js";const t={},m=l(`<blockquote><p>本文章为AcWing《算法基础课》的笔记</p></blockquote><h1 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h1><h2 id="基本思想" tabindex="-1"><a class="header-anchor" href="#基本思想" aria-hidden="true">#</a> 基本思想</h2><p>最基本思想：分治</p><ol><li><strong>选中一个分界值</strong>：可以是<code>q[l]</code>、<code>q[r]</code>、<code>q[l+r]</code>等；</li><li>**将数组分为两部分：**第一部分为小于边界值的，第二部分为大于边界值的；【难点】</li><li><strong>递归处理：<strong>对剩下的两部分重复上述过程，进行</strong>递归</strong>处理。</li></ol><h2 id="代码实现思路" tabindex="-1"><a class="header-anchor" href="#代码实现思路" aria-hidden="true">#</a> 代码实现思路</h2><h3 id="暴力-不推荐" tabindex="-1"><a class="header-anchor" href="#暴力-不推荐" aria-hidden="true">#</a> 暴力（不推荐）</h3><p>另外再开两个数组<code>a[ ]</code>、<code>b[ ]</code>，将<code>q[ ]</code>中大于边界的丢入<code>a[ ]</code>中，小于边界的丢入<code>b[ ]</code>中。然后放回<code>q[ ]</code>中。接着再对<code>q[ ]</code>中的两部分重复上述过程。</p><h3 id="优雅" tabindex="-1"><a class="header-anchor" href="#优雅" aria-hidden="true">#</a> 优雅</h3><h4 id="思路" tabindex="-1"><a class="header-anchor" href="#思路" aria-hidden="true">#</a> 思路</h4><blockquote><p>和数据结构教的一样</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>+--+--+--+--+--+--+--+--+--+--+--+--+
|  |  |  |  |  |  |  |  |  |  |  |  |
++-+--+--+--+--+--+--+--+--+--+--++-+
 ^                                ^
 |                                |
 +                                +
 i                                j

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>准备两个指针，一个指向最左端，一个指向最右端。</p><ul><li>对于最左端，如果当前数字比临界值小，则向右移动，直至遇到一个数字，<strong>大于等于</strong>临界值；</li><li>对于最右端，如果当前数字比临界值大，则向左移动，直至遇到一个数字，<strong>小于等于</strong>临界值；</li><li>此时交换左右两端数字。**交换完后，将两边指针各往前拨动一个，**接着重复上述过程；</li><li>直至两个指针重合。</li></ul><blockquote><p>当时疑惑了，为啥交换完后必须往前拨动一个？这是因为我们的条件是大于<strong>等于</strong>、小于<strong>等于</strong>！极有可能会遇到两个边界值（触发等于），换过后还是等于！陷入了死循环！所以换完必须往前拨动一个。</p></blockquote><h4 id="模板" tabindex="-1"><a class="header-anchor" href="#模板" aria-hidden="true">#</a> 模板</h4><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void quick_sort(int q[], int l, int r){
    //首先判断是否还需要排序
    if(l &gt;= r) return;
    
    //接着选取边界值，并初始化循环变量
    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];
    //然后进行循环
    while(i &lt; j){
        do i++; while(q[i] &lt; x);
        do j--; while(q[j] &gt; x);
        if(i &lt; j) swap(q[i], q[j]);//swap是C++内置函数
    }
    
    //最后进行递归
    quick_sort(q, l, j), quick_sort(q, j+1, r);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>如果最后一行进行递归时，中间边界选的是<code>j</code>、<code>j+1</code>，那么上面的边界值<code>x</code>不可以取<code>q[r]</code>，否则会有边界问题。故（同理，如果中间边界选的是<code>i-1</code>、<code>i</code>，那么上面的边界值<code>x</code>不可以取<code>q[l]</code>。）</p></blockquote>`,18),c=s("blockquote",null,[s("p",null,"Y总完整代码里，还有一句"),s("div",{class:"language-c++ line-numbers-mode","data-ext":"c++"},[s("pre",{class:"language-c++"},[s("code",null,`const int N =1e6 + 10;
int q[N];
`)]),s("div",{class:"line-numbers","aria-hidden":"true"},[s("div",{class:"line-number"}),s("div",{class:"line-number"})])]),s("p",null,[a("这是因为题目当中，规定了数据范围："),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mo",null,"≤"),s("mi",null,"n"),s("mo",null,"≤"),s("mn",null,"1000000")]),s("annotation",{encoding:"application/x-tex"},"1≤n≤1000000")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7804em","vertical-align":"-0.136em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7719em","vertical-align":"-0.136em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"≤"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1000000")])])]),a("，但有时测试样例中给的数会稍微多一些，于是便加了10。")])],-1),d=s("h2",{id:"时间复杂度",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#时间复杂度","aria-hidden":"true"},"#"),a(" 时间复杂度")],-1),r=s("p",null,[a("快排时间复杂度为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mi",null,"log"),s("mo",null,"⁡"),s("mi",null,"n"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(n \\log n)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mop"},[a("lo"),s("span",{style:{"margin-right":"0.01389em"}},"g")]),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mclose"},")")])])]),a("，这是最理想状态下（每次递归都是从中间分）的情况。")],-1),o=l(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>                        +
+-----------------------------------------------+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | O(n)
+-----------------------------------------------+
                        |
            +           |           +
+-----------------------------------------------+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | O(n)
+-----------------------------------------------+
            |           |           |
      +     |     +     |     +     |     +
+-----------------------------------------------+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | O(n)
+-----------------------------------------------+
      |     |     |     |     |     |     |
   +  |  +  |  +  |  +  |  +  |  +  |  +  |  +
+-----------------------------------------------+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | O(n)
+-----------------------------------------------+
   +  +  +  +  +  +  +  +  +  +  +  +  +  +  +

共logn层，故为O(n log n)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序" aria-hidden="true">#</a> 归并排序</h1><h2 id="基本思想-1" tabindex="-1"><a class="header-anchor" href="#基本思想-1" aria-hidden="true">#</a> 基本思想</h2><p>最基本思想：分治</p><h3 id="和快排的不同点" tabindex="-1"><a class="header-anchor" href="#和快排的不同点" aria-hidden="true">#</a> 和快排的不同点</h3><ul><li><strong>分治方式不一样</strong>：快排是随便选择一个<strong>数组中的数</strong>（虽然内心知道是有边界问题的不能瞎选），而归并是选择<strong>数组中间的位置</strong>；</li><li><strong>操作顺序不一样</strong>：快排是先操作再递归，归并是上来先递归再操作。</li></ul><h3 id="基本步骤" tabindex="-1"><a class="header-anchor" href="#基本步骤" aria-hidden="true">#</a> 基本步骤</h3><ol><li>**选取分界值：**选取数组中间的位置<code>(l + r) /2</code></li><li>**递归：**对左右两侧进行递归处理</li><li>**归并：**将左右两侧结果合并【难点】</li></ol><h2 id="代码实现思路-1" tabindex="-1"><a class="header-anchor" href="#代码实现思路-1" aria-hidden="true">#</a> 代码实现思路</h2><blockquote><p>关键看第三步，如何对两侧结果进行合并</p></blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>          +
          |
          |
          |
         +v-+--+--+--+--+--+
前半部分 |  |  |  |  |  |  | 排好序了
         +--+--+--+--+--+--+

         +--+--+--+--+--+--+
后半部分 |  |  |  |  |  |  | 排好序了
         +^-+--+--+--+--+--+
          |
          |
          +

         +--+--+--+--+--+--+--+--+--+--+--+--+
最终结果 |  |  |  |  |  |  |  |  |  |  |  |  |
         +--+--+--+--+--+--+--+--+--+--+--+--+

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>核心：双指针算法。假定已经有两个<strong>排好序</strong>的子数组。</p><ul><li>比较：两个指针所指的数字谁更小？谁小，把谁丢入结果数组，并且自己的指针往后移一个，进行下一轮比较；</li><li>如果有一个子数组的指针已经指向最后一个元素了，此时直接将另一个子数组剩下的元素丢尽最终结果就好。</li></ul><blockquote><p>如果两个数字相同，则将“前面半段”的数丢入最终结果。这是为了保证稳定性。</p></blockquote><h2 id="模板-1" tabindex="-1"><a class="header-anchor" href="#模板-1" aria-hidden="true">#</a> 模板</h2><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>void merge_sort(int q[], int l, int r)
{
    //判断是否还有元素要处理
    if (l &gt;= r) return;
    //计算分界点
    int mid = l + r &gt;&gt; 1;
    //上来先是递归
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    //将两段数据合并
    int k = 0, i = l, j = mid + 1;
    while (i &lt;= mid &amp;&amp; j &lt;= r) //谁小复制谁
        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ]; //如果两者相等，复制前面的数据
        else tmp[k ++ ] = q[j ++ ];
    //将没处理完的直接拼在临时数组后面
    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];
    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];
    //最后将tmp数组中内容写回至原数组中
    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="整数二分" tabindex="-1"><a class="header-anchor" href="#整数二分" aria-hidden="true">#</a> 整数二分</h1><h2 id="基本思想-2" tabindex="-1"><a class="header-anchor" href="#基本思想-2" aria-hidden="true">#</a> 基本思想</h2><p>有单调性的一定可以用二分，可以用二分的未必有单调性。</p><p>对于给定的<strong>整数</strong>区间（当前讨论的是<strong>整数</strong>二分），可以分成两个部分（这并不是二分的含义，二分是指将区间均匀分成两部分），一部分是满足给定性质的，另一部分是不满足给定性质的。如下图所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>         Satisfy                Not   Satisfy
|___________________|__|________________________________| 第一种情况
l                   k k+1                               r

    Not  Satisfy                      Satisfy
|___________________|__|________________________________| 第二种情况
l                   k k+1                               r
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了找到边界，我们可以去寻找<code>k</code>，也可以去寻找<code>k+1</code>。</p><p>寻找不同的值，对应着不同的模板。</p><p>核心想法：保证<strong>要找的那个边界</strong>一定要在正在找的那个<strong>区间内</strong>！</p><h3 id="模板1" tabindex="-1"><a class="header-anchor" href="#模板1" aria-hidden="true">#</a> 模板①</h3><p>模板①：以上图中第一种情况为例，我们要寻找<code>k</code>，即<strong>左边</strong>这个区间的<strong>右边界</strong>。</p><ol><li>确定分界点<code>mid = (l + r + 1) / 2</code></li><li>查看该点处数值是否满足条件（本质：判断<code>mid</code>是属于左边的还是右边的） <ol><li>满足条件，说明边界还要靠右。把<code>l</code>（左边界）改成<code>mid</code> ，即寻找范围为：<code>[mid, r]</code><em>存疑，那如果mid就是边界呢？不过这种方式把mid仍然算在寻找范围内，下面的<code>mid-1</code>就是把<code>mid</code>点给排除掉了</em></li><li>不满足条件，说明边界还要靠左。把<code>r</code>（右边界）改成<code>mid - 1</code>，即寻找范围为：<code>[l, mid - 1]</code><em>排除掉了<code>mid</code>点</em></li></ol></li></ol><blockquote><p>为什么求左边区间的右边界（即在满足条件时把<code>l</code>更新为<code>mid</code>，搜索区间变为<code>[mid, r]</code>）时，<code>mid</code>点要<strong>加一再除二</strong>，选为<code>(l + r + 1) / 2</code>呢？试想如果当<code>l = r - 1</code>，且没有加一，此时<code>mid = (l + r) / 2 = (r + r - 1) / 2 = r - 1 = l</code>（除法是向下取整） 。如果<code>mid</code>点符合要求，下次寻找范围为<code>[mid, r]</code>，仍为<code>[l, r]</code>，陷入了死循环。所以<code>mid</code>点要<strong>加一再除二</strong>。</p></blockquote><h3 id="模板2" tabindex="-1"><a class="header-anchor" href="#模板2" aria-hidden="true">#</a> 模板②</h3><p>模板②：如果是找<strong>右边区间</strong>的<strong>左边界</strong>，则思路如下：</p><ol><li>确定分界点**<code>mid = (l + r) / 2</code>**</li><li>查看该点处数值是否满足条件（本质：判断<code>mid</code>是属于左边的还是右边的） <ol><li>满足条件，说明边界还要<strong>靠左</strong>。把<code>r</code>（左边界）改成<code>mid</code> ，即寻找范围为：<strong><code>[l, mid]</code></strong></li><li>不满足条件，说明边界还要<strong>靠右</strong>。把<code>l</code>（右边界）改成<code>mid + 1</code>，即寻找范围为：<strong><code>[mid + 1, r]</code></strong> <em>排除掉了<code>mid</code>点</em></li></ol></li></ol><h3 id="模板选择" tabindex="-1"><a class="header-anchor" href="#模板选择" aria-hidden="true">#</a> 模板选择</h3><p>什么时候用模板①，什么时候用模板②呢？</p><p>首先注意到：<code>mid = l + r + 1 &gt;&gt; 1</code>和<code>l = mid</code>是绑定的；<code>mid = l + r &gt;&gt; 1</code>和<code>r = mid</code>是绑定的。</p><ul><li>先把<code>mid = l + r &gt;&gt; 1</code>写上*（先不管是不是<code>+ 1</code>）*</li><li>然后写<code>check</code>函数/条件（如：<code>q[i] &gt;= x</code>）</li><li>符合<code>check</code>条件的区间是左半边还是右半边？如果<code>mid</code>点满足条件，下一个搜寻区间在右半边<code>[r, mid]</code>，还是在左半边<code>[l, mid]</code>？ <ul><li>如果符合<code>check</code>条件的区间是左半边，那么下一个搜寻区间是右半边<code>[mid, r]</code>（<code>mid</code>也有可能是答案），<strong>即<code>l = mid</code></strong>，那么上面写过的<code>mid</code>表达式改为<code>mid = (l + r + 1) &gt;&gt; 1</code></li><li>如果符合<code>check</code>条件的区间是右半边，下一个搜寻区间是左半边<code>[l, mid]</code>（<code>mid</code>也有可能是答案），<strong>即<code>r = mid</code></strong>，那么上面写过的<code>mid</code>表达式无需更改</li></ul></li></ul><h2 id="模板-2" tabindex="-1"><a class="header-anchor" href="#模板-2" aria-hidden="true">#</a> 模板</h2><p>使用二分法，我们是保证答案一定在区间里面的；如果区间的长度为1，说明这个数便是最终的答案。<code>解释模板l &lt; r停止条件</code></p><p><strong>题目可能是无解的</strong>，但是这个代码<strong>模板一定是能出来一个解</strong>的！针对题目要求，可能要在循环后加以判断！</p><p>注意点：</p><ul><li>我们先写<code>int mid = l + r &gt;&gt; 1</code></li><li>在确定是<code>l = mid</code> OR <code>r = mid</code>后再根据情况回去修改<code>mid</code></li></ul><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r &gt;&gt; 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l &lt; r)
    {
        int mid = l + r + 1 &gt;&gt; 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="浮点二分" tabindex="-1"><a class="header-anchor" href="#浮点二分" aria-hidden="true">#</a> 浮点二分</h1><h2 id="基本思想-3" tabindex="-1"><a class="header-anchor" href="#基本思想-3" aria-hidden="true">#</a> 基本思想</h2><p>与整数不同，不需要太怎么考虑边界问题。</p><p>与整数类似，都是要保证要找的边界在区间内；</p><p>每次将搜索的区间砍成一半，当区间足够小时，我们认为已经找到了答案。</p><h2 id="模板-3" tabindex="-1"><a class="header-anchor" href="#模板-3" aria-hidden="true">#</a> 模板</h2><p>这里以求二次方根的题目来代替模板</p><p>注意点：</p>`,49),p=s("ul",null,[s("li",null,[a("如果题目要求6位小数，则"),s("code",null,"r - l > 1e-8"),a("才行。也就是说，假如"),s("code",null,"n"),a("是要求的精度，那么"),s("code",null,"r - l"),a("要小于"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mrow",null,[s("mo",null,"−"),s("mo",{stretchy:"false"},"("),s("mi",null,"n"),s("mo",null,"+"),s("mn",null,"2"),s("mo",{stretchy:"false"},")")])])]),s("annotation",{encoding:"application/x-tex"},"10^{-(n+2)}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.888em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.888em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord mtight"},"−"),s("span",{class:"mopen mtight"},"("),s("span",{class:"mord mathnormal mtight"},"n"),s("span",{class:"mbin mtight"},"+"),s("span",{class:"mord mtight"},"2"),s("span",{class:"mclose mtight"},")")])])])])])])])])])])]),a("才可以")]),s("li",null,[a("关于边界的选取：假设要解"),s("code",null,"0.01"),a("的根，如果区间选在"),s("code",null,"[0, 0.01]"),a("（即"),s("code",null,"l=0;r=x"),a("），此时发现根"),s("code",null,"0.1"),a("是不在区间内部的，这会造成出来的结果不对（事实上会返回"),s("code",null,"0.01"),a("）！于是做出了改进：让右边界为"),s("code",null,"r=x+1"),a("便可解决这里的问题。")])],-1),h=l(`<div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    double x;
    cin &gt;&gt; x;
    
    double l = 0, r=x+1; //NOTICE r=x+1
    while(r - l &gt; 1e-6) { //NOTICE 1e-6
        double mid = (l+r) / 2;
        if(mid * mid * mid &gt; x) r = mid;
        else l = mid;
    }
    
    printf(&quot;%lf&quot;, l);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="高精度" tabindex="-1"><a class="header-anchor" href="#高精度" aria-hidden="true">#</a> 高精度</h1><h2 id="算法思想" tabindex="-1"><a class="header-anchor" href="#算法思想" aria-hidden="true">#</a> 算法思想</h2><p>Java有大整数类，Python的精度够，只有C++会考虑。主要有以下四种情况：</p>`,4),u=s("ul",null,[s("li",null,[a("第一种：两个大整数相加："),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"A"),s("mo",null,"+"),s("mi",null,"B")]),s("annotation",{encoding:"application/x-tex"},"A+B")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05017em"}},"B")])])]),a("，其中"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"l"),s("mi",null,"e"),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"A"),s("mo",{stretchy:"false"},")"),s("mo",null,"⩽"),s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"6")]),s("mo",{separator:"true"},","),s("mi",null,"l"),s("mi",null,"e"),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"A"),s("mo",{stretchy:"false"},")"),s("mo",null,"⩽"),s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"6")])]),s("annotation",{encoding:"application/x-tex"},"len(A) \\leqslant 10^6, len(A) \\leqslant 10^6")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel amsrm"},"⩽"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"6")])])])])])])]),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel amsrm"},"⩽"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"6")])])])])])])])])])])]),s("li",null,[a("第二种：两个大整数相减："),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"A"),s("mo",null,"−"),s("mi",null,"B")]),s("annotation",{encoding:"application/x-tex"},"A-B")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6833em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05017em"}},"B")])])]),a("，其中"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"l"),s("mi",null,"e"),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"A"),s("mo",{stretchy:"false"},")"),s("mo",null,"⩽"),s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"6")]),s("mo",{separator:"true"},","),s("mi",null,"l"),s("mi",null,"e"),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"A"),s("mo",{stretchy:"false"},")"),s("mo",null,"⩽"),s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"6")])]),s("annotation",{encoding:"application/x-tex"},"len(A) \\leqslant 10^6, len(A) \\leqslant 10^6")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel amsrm"},"⩽"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0641em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"6")])])])])])])]),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel amsrm"},"⩽"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.8141em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"6")])])])])])])])])])])]),s("li",null,[a("第三种：一个大整数乘上一个小整数"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"A"),s("mo",null,"×"),s("mi",null,"α")]),s("annotation",{encoding:"application/x-tex"},"A \\times \\alpha")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"×"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α")])])]),a("，其中"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"l"),s("mi",null,"e"),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"A"),s("mo",{stretchy:"false"},")"),s("mo",null,"⩽"),s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"6")]),s("mo",{separator:"true"},","),s("mi",null,"α"),s("mo",null,"⩽"),s("mn",null,"1000")]),s("annotation",{encoding:"application/x-tex"},"len(A) \\leqslant 10^6, \\alpha \\leqslant 1000")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel amsrm"},"⩽"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0085em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"6")])])])])])])]),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel amsrm"},"⩽"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1000")])])])]),s("li",null,[a("第四种：一个大整数除以一个小整数"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"A"),s("mo",null,"÷"),s("mi",null,"α")]),s("annotation",{encoding:"application/x-tex"},"A\\div \\alpha")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"÷"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α")])])]),a("，其中"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"l"),s("mi",null,"e"),s("mi",null,"n"),s("mo",{stretchy:"false"},"("),s("mi",null,"A"),s("mo",{stretchy:"false"},")"),s("mo",null,"⩽"),s("mn",null,"1"),s("msup",null,[s("mn",null,"0"),s("mn",null,"6")]),s("mo",{separator:"true"},","),s("mi",null,"α"),s("mo",null,"⩽"),s("mn",null,"1000")]),s("annotation",{encoding:"application/x-tex"},"len(A) \\leqslant 10^6, \\alpha \\leqslant 1000")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"e"),s("span",{class:"mord mathnormal"},"n"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel amsrm"},"⩽"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0085em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mord"},[s("span",{class:"mord"},"0"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8141em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},"6")])])])])])])]),s("span",{class:"mpunct"},","),s("span",{class:"mspace",style:{"margin-right":"0.1667em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.0037em"}},"α"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel amsrm"},"⩽"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1000")])])])])],-1),g=l('<h2 id="大整数的存法" tabindex="-1"><a class="header-anchor" href="#大整数的存法" aria-hidden="true">#</a> 大整数的存法</h2><p>我们使用数组来存储大整数的每一位。并将低位放在数组开头，高位放在数组结尾。</p><blockquote><p>例如：对于数字<code>123456789</code>，将其每一位存到数组中后，是这样的：<code>q[0] == 9</code>、<code>q[1] == 8</code>、...etc。</p></blockquote><p>这么做的好处是：如果最高位涉及到进位，我们需要在最高位前面再添一个数字时，可以直接在数组的末尾添上；如果采取高位放在数组开头的做法，进位时在数组最前面不太方便添数字。</p>',4),v=[m,c,d,r,o,p,h,u,g];function b(_,x){return n(),i("div",null,v)}const k=e(t,[["render",b],["__file","basic-1.html.vue"]]);export{k as default};
