import{_ as e,W as c,X as d,$ as i}from"./framework-11db905c.js";const n={},a=i(`<h1 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h1><p>数组是一种数据格式，能够存储多个<strong>同类型</strong>的数值。</p><p>声明数组的通用格式：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>typeName arrayName[arraySize];
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="初始化数组元素" tabindex="-1"><a class="header-anchor" href="#初始化数组元素" aria-hidden="true">#</a> 初始化数组元素</h2><p>我们可以使用大括号初始化方法<strong>在声明时</strong>（且<strong>仅</strong>在声明时）将数组初始化。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int scores[5] = {1, 2, 3, 4, 5};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不能将一个数组直接赋值给另一个数组。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int scores[5] = {1, 2, 3, 4, 5};
int ranks[5] = scores;//not allowed
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化时提供的<strong>元素值的个数</strong>可以<strong>少于</strong>数组的<strong>元素数目</strong>，此时其他元素会被设置为<code>0</code>。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int scores[5] = {0, 1};
cout &lt;&lt; scores[2];//0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>于是如果想把数组全部初始化为0，可以这么做：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int scores[5] = {0};
int scores[5] = {};//c++11，略掉了0
int scores[5]{};//c++11，略掉了等号和0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p>初始化时不提供<code>[]</code>内的值，那么C++编译器将自动计算元素个数。</p><p>值得一提的是，使用列表初始化时，不允许<strong>缩窄转换</strong>（备忘：硬赋“吃不下”的值）。</p><h2 id="针对数组的sizeof" tabindex="-1"><a class="header-anchor" href="#针对数组的sizeof" aria-hidden="true">#</a> 针对数组的<code>sizeof</code></h2><p><code>sizeof</code>作用于<strong>数组名</strong>，得到的是整个数组的字节数；作用于数组中的某个元素，则是单个该元素占用的字节数。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int scores[5] = {1, 2, 3, 4, 5};
cout &lt;&lt; sizeof scores &lt;&lt; endl;//20 p.s. 4 * 5 = 20
cout &lt;&lt; sizeof scores[2] &lt;&lt; endl;//4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h1><blockquote><p>此处先介绍C风格字符串（char数组），下一小节介绍<code>string</code>类</p></blockquote><p><code>char</code>数组不一定是字符串，因为字符串要求以<code>\\0</code>结尾。如果一个<code>char</code>数组并未以<code>\\0</code>结尾，那么不应视为字符串处理，更不应使用相关函数对其进行处理，否则这些函数会一直顺着内存读下去，直至遇到<code>\\0</code>。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>char c1[] = {&#39;h&#39;, &#39;i&#39;};//Not a string
char c2[] = {&#39;h&#39;, &#39;i&#39;, &#39;\\0&#39;};//Right
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="初始化字符串" tabindex="-1"><a class="header-anchor" href="#初始化字符串" aria-hidden="true">#</a> 初始化字符串</h2><p>我们可以使用<strong>字符串常量</strong>对<code>char</code>数组进行初始化</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>char c1[] = &quot;Aoligei!&quot;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用<strong>双引号</strong>扩起的字符串<strong>隐式地包括结尾的空字符</strong>，譬如：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>char c1[8] = &quot;Bozo&quot;;
// B o z o \\0(这个是自动加到字符串末尾的，后续其他的也会设置为\\0) \\0 \\0 \\0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container danger"><p class="custom-container-title">区分字符常量和字符串常量</p><p>字符常量用<strong>单引号</strong>包裹，<strong>本质是</strong>字符串<strong>编码</strong>的简略表示。在ASCII系统中，<code>&#39;s&#39; == 83</code>，<code>&#39;s&#39;</code>只是<code>83</code>的另外一个写法罢了。</p><p>字符串常量用<strong>双引号</strong>包裹，如<code>&quot;s&quot;</code>，其代表由<code>&#39;s&#39;</code>、<code>&#39;\\0&#39;</code>组成的字符串。C++中视为字符串<strong>所在的内存地址</strong>。</p></div><h2 id="字符串常量拼接" tabindex="-1"><a class="header-anchor" href="#字符串常量拼接" aria-hidden="true">#</a> 字符串常量拼接</h2><p>任何两个被空白（空格、制表符、换行符）分割开来的字符串会被自动拼接成一个。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>char c1[] = &quot;Aoligei!&quot;
            &quot;Split!&quot;;
cout &lt;&lt; c1;//Aoligei!Split!
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="strlen的使用" tabindex="-1"><a class="header-anchor" href="#strlen的使用" aria-hidden="true">#</a> <code>strlen</code>的使用</h2><p>要想使用<code>strlen</code>，需要包含<code>cstring</code>头文件。</p><p><code>strlen</code>只计算可见字符，且不把空字符<code>\\0</code>计算在内。</p><h2 id="读取字符串" tabindex="-1"><a class="header-anchor" href="#读取字符串" aria-hidden="true">#</a> 读取字符串</h2><p>我们可以使用<code>cin</code>来读取字符串。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>char c1[20] = {};
char c2[20] = {};
cin &gt;&gt; c1;
cin &gt;&gt; c2;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意：如果在读取<code>c1</code>的时候，输入了<code>Ao ligei</code>并按下回车，那么会赋给<code>c1</code>为<code>Ao</code>，且赋给<code>c2</code>为<code>ligei</code>。这和<code>cin</code>的实现有关系。其以<strong>空白（空格、制表符和换行符）来确定字符串的结束位置</strong>，因而会把<code>Ao</code>赋给<code>c1</code>，此时缓冲区里还有<code>ligei\\n</code>，于是接下来的<code>cin</code>便直接将<code>ligei</code>赋给了<code>c2</code>。</p><h2 id="cin-getline-和cin-get" tabindex="-1"><a class="header-anchor" href="#cin-getline-和cin-get" aria-hidden="true">#</a> <code>cin.getline()</code>和<code>cin.get()</code></h2><p>这两个函数和普通的<code>cin</code>区别在于：<code>getline</code>和<code>get</code><strong>仅以换行符作为字符串结束的标志</strong>，亦即一次可以读取一行，而不管中间有没有空格。</p><p>用法：<code>cin.getline(name, ArSize)</code>，<code>cin.get(name, ArSize)</code></p><p><code>getline</code>和<code>get</code>的区别在于：<code>getline</code>会把缓冲区中的<code>\\n</code>读取并丢弃掉，而<code>get</code>并不会。所以当使用<code>get</code>来读取一行的内容时，通常还需要再调用（什么也没有的参数）<code>get</code>手动读取掉（下一个字符）<code>\\n</code>，如：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>char c1[20];
cin.get(c1, 10).get();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>cin.get(c1, 10)</code>返回一个<code>cin</code>对象，所以后边还能再跟一个<code>.get()</code>。</p><p><code>cin.get(name, ArSize)</code>的一个好处在于：可以知道停止读取的原因（是读够了，还是遇到<code>\\n</code>了？）。只需读完后再调用<code>cin.get()</code>获取下一个字符，查看是不是<code>\\n</code>即可。</p><h2 id="读取空行" tabindex="-1"><a class="header-anchor" href="#读取空行" aria-hidden="true">#</a> 读取空行</h2><p>使用<code>cin.get()</code>（<code>cin.getline()</code>不会）读取到空行时，会设置一个失效位，阻塞下面所有的<code>cin</code>相关输入，此时需要用<code>cin.clear()</code>来重置失效位。</p><h2 id="混合cin和cin-getline" tabindex="-1"><a class="header-anchor" href="#混合cin和cin-getline" aria-hidden="true">#</a> 混合<code>cin</code>和<code>cin.getline()</code></h2><p><code>cin</code>从输入流中获取字符串后，不会清掉buffer，如果接着用<code>cin.getline()</code>，那么会得到一个空串。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>char c1[30]{};
char c2[30]{};

cin &gt;&gt; c1;
cin.getline(c2, 30);
cout &lt;&lt; &quot;c1: &quot; &lt;&lt; c1 &lt;&lt; endl;
cout &lt;&lt; &quot;c2: &quot; &lt;&lt; c2 &lt;&lt; endl;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>键入<code>hello</code>后按下回车，（还没输入<code>c2</code>的值）输出为：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>c1: hello
c2: 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法也很简单，只需将<code>cin &gt;&gt; c1;</code>改成<code>(cin &gt;&gt; c1).get();</code>（是的！<code>cin &gt;&gt; c1</code>也会返回一个<code>istream</code>对象出来！）</p><h1 id="string类简介" tabindex="-1"><a class="header-anchor" href="#string类简介" aria-hidden="true">#</a> string类简介</h1><p><code>string</code>类<strong>隐藏了</strong>字符串的<code>char</code><strong>数组性质</strong>，使得我们可以像使用普通变量那样处理字符串。</p><ul><li>可以使用C风格字符串来初始化<code>string</code>对象：<code>string x = &quot;hello&quot;;</code></li><li>可以使用<code>cin</code>来将键盘中的输入存储到<code>string</code>对象中：<code>cin &gt;&gt; x;</code></li><li>可以使用<code>cout</code>来显示<code>string</code>对象：<code>cout &lt;&lt; x;</code></li></ul><p>类设计使得<code>string</code>对象可以自动调整大小。譬如我们在声明<code>string</code>对象时，并没有像使用<code>char</code>数组那样，指定元素个数。</p><h2 id="初始化string" tabindex="-1"><a class="header-anchor" href="#初始化string" aria-hidden="true">#</a> 初始化<code>string</code></h2><p>既可以用C风格字符串，也可以用列表初始化。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>string x1 = &quot;Hello,&quot;;
string x2 {&quot;world!&quot;};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="string对象身上的操作" tabindex="-1"><a class="header-anchor" href="#string对象身上的操作" aria-hidden="true">#</a> <code>string</code>对象身上的操作</h2><p>我们可以将一个<code>string</code>对象<strong>赋给</strong>另一个<code>string</code>对象，这也算是<strong>复制</strong>操作了。（<code>char</code>数组就不能这么玩，并且还要用<code>strcpy</code>函数）</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>string x1 = &quot;Hello&quot;;
string x2 = x1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以用<code>+</code>运算符将两个<code>string</code>对象合并起来。（如果是<code>char</code>数组得用<code>strcat</code>函数）</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>string x3 = x1 + x2;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们可以用类方法<code>size()</code>来获取字符串长度。（如果是<code>char</code>数组得用<code>strlen</code>函数）</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>cout &lt;&lt; x1.size();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="string类io" tabindex="-1"><a class="header-anchor" href="#string类io" aria-hidden="true">#</a> <code>string</code>类IO</h2>`,67),o=[a];function s(r,l){return c(),d("div",null,o)}const g=e(n,[["render",s],["__file","unit4.html.vue"]]);export{g as default};
