import{_ as r,F as a,W as s,X as c,Y as t,Z as e,a0 as i,$ as n}from"./framework-9c1141cc.js";const l={},h=n('<h2 id="优化策略概览" tabindex="-1"><a class="header-anchor" href="#优化策略概览" aria-hidden="true">#</a> 优化策略概览</h2><blockquote><p>Performance optimization revolves around four basic strategies:</p><ul><li>Maximize parallel execution to achieve maximum utilization;</li><li>Optimize memory usage to achieve maximum memory throughput;</li><li>Optimize instruction usage to achieve maximum instruction throughput;</li><li>Minimize memory thrashing.</li></ul></blockquote><p>性能优化围绕四个基本策略展开：</p><ul><li><p><strong>最大化并行执行</strong>，实现最大利用率；</p></li><li><p><strong>优化内存使用</strong>，实现最大内存吞吐量；</p></li><li><p><strong>优化指令使用</strong>，实现最大指令吞吐量；</p></li><li><p><strong>尽量减少内存抖动</strong></p></li></ul><div class="hint-container info"><p class="hint-container-title">内存抖动</p><p>内存抖动应该是指内存页面频繁的换入换出</p></div><blockquote><p>Which strategies will yield the best performance gain for a particular portion of an application depends on the performance limiters for that portion; optimizing instruction usage of a kernel that is mostly limited by memory accesses will not yield any significant performance gain, for example. Optimization efforts should therefore be constantly directed by measuring and monitoring the performance limiters, for example using the CUDA profiler. Also, comparing the floating-point operation throughput or memory throughput—whichever makes more sense—of a particular kernel to the corresponding peak theoretical throughput of the device indicates how much room for improvement there is for the kernel.</p></blockquote><p>对于应用程序的特定部分， 哪种优化策略能取得最大的性能提升， 取决于<strong>到底是哪部分限制住了性能</strong>；例如， 对受内存访问限制的内核进行指令上的优化， 不会带来任何显著的性能提升。 因此， 应<strong>通过测量和监控</strong>（例如使用 CUDA profiler），去<strong>发现性能限制因素</strong>，再来不断指导优化工作。 此外， 将特定内核的浮点运算吞吐量或内存吞吐量（以更合理的方式为准） 与相应设备的理论峰值吞吐量进行比较，可以显示内核的改进空间有多大。</p><h2 id="最大化利用率" tabindex="-1"><a class="header-anchor" href="#最大化利用率" aria-hidden="true">#</a> 最大化利用率</h2><blockquote><p>To maximize utilization the application should be structured in a way that it exposes as much parallelism as possible and efficiently maps this parallelism to the various components of the system to keep them busy most of the time.</p></blockquote><p>为了最大限度地提高利用率， 应用程序的结构应尽可能多地<strong>暴露出并行性</strong>， 并有效地<strong>将这种并行性映射到系统的各个组件上</strong>，使它们在大部分时间内都处于忙碌状态。</p><h3 id="应用层面" tabindex="-1"><a class="header-anchor" href="#应用层面" aria-hidden="true">#</a> 应用层面</h3>',11),d=t("strong",null,"using asynchronous functions calls and streams",-1),u={href:"https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#asynchronous-concurrent-execution",target:"_blank",rel:"noopener noreferrer"},p=n('<p>在高层次上， 应用程序应通过使用==<strong>异步函数调用和流机制</strong>==（如异步并发执行中所述），最大限度地提高主机、 设备以及连接主机和设备的总线之间的并行执行能力。 它应为每个处理器分配其最擅长的工作类型：串行工作负载分配给主机；并行工作负载分配给设备。</p><blockquote><p>For the parallel workloads, at points in the algorithm where parallelism is broken because some threads need to synchronize in order to share data with each other, there are two cases: Either these threads belong to the same block, in which case they should use <code>__syncthreads()</code> and share data through shared memory within the same kernel invocation, or they belong to different blocks, in which case they must share data through global memory using two separate kernel invocations, one for writing to and one for reading from global memory. The second case is much less optimal since it adds the overhead of extra kernel invocations and global memory traffic. Its occurrence should therefore be minimized by mapping the algorithm to the CUDA programming model in such a way that the computations that require inter-thread communication are performed within a single thread block as much as possible.</p></blockquote><p>对于并行工作负载，在算法中由于<strong>某些线程需要同步以相互共享数据而导致并行性中断</strong>的地方，<strong>有两种情况</strong>：<strong>要么这些线程属于同一个Block</strong>，在这种情况下，它们应该使用<code>syncthreads()</code>并在同一个内核调用中<strong>通过共享存储器</strong>共享数据；<strong>要么它们属于不同的区块</strong>，在这种情况下，它们必须<strong>调用两个单独的内核通过全局存储器</strong>共享数据，一个用于写入全局内存，另一个用于从全局内存读取数据。第二种情况并不理想，因为它会增加额外的内核调用和全局存储器流量。因此，在将算法映射到CUDA编程模型时，线程间若需要需要通信，应尽可能<strong>在单个线程块内执行计算</strong>，从而最大限度地减少这种情况的发生。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>总结：</p><ul><li>异步函数调用和流机制</li><li>当线程间需要通信时，尽量在单个线程块内执行</li></ul></div><h3 id="设备层面" tabindex="-1"><a class="header-anchor" href="#设备层面" aria-hidden="true">#</a> 设备层面</h3><blockquote><p>At a lower level, the application should maximize parallel execution between the multiprocessors of a device.</p></blockquote><p>在较低层次上，应用程序应最大限度地在设备的多处理器之间并行执行。</p>',7),m={href:"https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#asynchronous-concurrent-execution",target:"_blank",rel:"noopener noreferrer"},g=n('<p>一个设备上可同时执行多个内核，因此，如异步并发执行中所述，使用流机制使足够多的内核同时执行，也可实现最大利用率。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>总结：使用流机制让内核并行</p></div><h3 id="sm层面" tabindex="-1"><a class="header-anchor" href="#sm层面" aria-hidden="true">#</a> SM层面</h3><blockquote><p>At an even lower level, the application should <strong>maximize parallel execution between the various functional units</strong> within a multiprocessor.</p></blockquote><p>在更低的层次上，应用程序应最大限度地利用<strong>多处理器内各功能单元之间的并行执行</strong>。</p>',5),f={href:"https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#hardware-multithreading",target:"_blank",rel:"noopener noreferrer"},_={href:"https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#simt-architecture-notes",target:"_blank",rel:"noopener noreferrer"},b=t("em",null,"latency",-1),y={href:"https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions",target:"_blank",rel:"noopener noreferrer"},k={href:"https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#hardware-multithreading",target:"_blank",rel:"noopener noreferrer"},v=t("strong",null,"主要依靠线程级并行",-1),x=t("strong",null,"利用同一 warp 的另一条独立指令（指令级并行性）",-1),w=t("strong",null,"利用另一个 warp 的指令（线程级并行性）",-1),z={href:"https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#simt-architecture-notes",target:"_blank",rel:"noopener noreferrer"},q=t("strong",null,[e("线程束准备好执行下一条指令所需的时钟周期数称为"),t("em",null,"延迟")],-1),A={href:"https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions",target:"_blank",rel:"noopener noreferrer"},C=t("strong",null,"吞吐量",-1),I={class:"hint-container info"},U=t("p",{class:"hint-container-title"},"吞吐量",-1),E={href:"https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#maximize-instruction-throughput",target:"_blank",rel:"noopener noreferrer"};function T(M,P){const o=a("ExternalLinkIcon");return s(),c("div",null,[h,t("blockquote",null,[t("p",null,[e("At a high level, the application should maximize parallel execution between the host, the devices, and the bus connecting the host to the devices, by "),d,e(" as described in "),t("a",u,[e("Asynchronous Concurrent Execution"),i(o)]),e(". It should assign to each processor the type of work it does best: serial workloads to the host; parallel workloads to the devices.")])]),p,t("blockquote",null,[t("p",null,[e("Multiple kernels can execute concurrently on a device, so maximum utilization can also be achieved by using streams to enable enough kernels to execute concurrently as described in "),t("a",m,[e("Asynchronous Concurrent Execution"),i(o)]),e(".")])]),g,t("blockquote",null,[t("p",null,[e("As described in "),t("a",f,[e("Hardware Multithreading"),i(o)]),e(", a GPU multiprocessor primarily relies on thread-level parallelism to maximize utilization of its functional units. Utilization is therefore directly linked to the number of resident warps. At every instruction issue time, a warp scheduler selects an instruction that is ready to execute. This instruction can be another independent instruction of the same warp, exploiting instruction-level parallelism, or more commonly an instruction of another warp, exploiting thread-level parallelism. If a ready to execute instruction is selected it is issued to the "),t("a",_,[e("active"),i(o)]),e(" threads of the warp. The number of clock cycles it takes for a warp to be ready to execute its next instruction is called the "),b,e(", and full utilization is achieved when all warp schedulers always have some instruction to issue for some warp at every clock cycle during that latency period, or in other words, when latency is completely “hidden”. The number of instructions required to hide a latency of L clock cycles depends on the respective throughputs of these instructions (see "),t("a",y,[e("Arithmetic Instructions"),i(o)]),e(" for the throughputs of various arithmetic instructions). If we assume instructions with maximum throughput, it is equal to:")])]),t("p",null,[e("如"),t("a",k,[e("硬件多线程"),i(o)]),e("所述，GPU 多处理器"),v,e("来最大限度地利用其功能单元。因此，利用率与常驻的线程束数量直接相关。在每条指令发出时，线程束调度器都会选择一条准备执行的指令。这条指令可以是"),x,e("，也可以是"),w,e("。如果选择了一条准备执行的指令，它就会被发射给该 warp 的"),t("a",z,[e("活跃"),i(o)]),e("线程。"),q,e('，当所有线程束调度器在该延迟期内的每个时钟周期都要为一些线程束发射指令时，或者换句话说，当延迟被完全 "隐藏"时，就实现了充分利用。隐藏 L 个时钟周期的延迟所需的指令数取决于这些指令各自的吞吐量（各种算术指令的吞吐量参见 '),t("a",A,[e("算术指令"),i(o)]),e("）。如果假定指令的"),C,e("最大，则等于：")]),t("div",I,[U,t("p",null,[e("关于吞吐量定义可见"),t("a",E,[e("这里"),i(o)]),e("。")])])])}const D=r(l,[["render",T],["__file","chap_8_Performance_guidelines.html.vue"]]);export{D as default};
