import{_ as e,W as t,X as c,$ as s}from"./framework-53680ed3.js";const o={},i=s('<p>实验二要求依据我们在实验一建立起来的语法分析树，进行语义分析。</p><h1 id="过程概览" tabindex="-1"><a class="header-anchor" href="#过程概览" aria-hidden="true">#</a> 过程概览</h1><ol><li>词法、语法分析，<strong>先</strong>得到一棵<strong>语法分析树</strong>；</li><li>对语法分析树进行<strong>遍历</strong>，进行语义分析，（如果没有错误）得到<strong>语义分析表</strong>；</li></ol><p>上课讲的声明语句(即填表)例子，是将填表过程(SDT)融合在语法分析过程(Bison)中的。</p><p>而实验手册的意思是先有树，再单独分析；可是，<strong>分析的过程是需要用到SDT的哇</strong>！如果不把SDT融合在Bison里，那还得<strong>根据生成好的树</strong>去<strong>看每一步推导用了啥产生式</strong>，进而确定具体的动作。</p><p>怎么<code>根据生成好的树去看每一步推导用了啥产生式</code>呢？==&gt;<strong>仿照自顶向下的递归分析</strong>过程！</p><h1 id="符号表" tabindex="-1"><a class="header-anchor" href="#符号表" aria-hidden="true">#</a> 符号表</h1><h2 id="方案" tabindex="-1"><a class="header-anchor" href="#方案" aria-hidden="true">#</a> 方案</h2><p>链表（没能力的人是这样的呜呜）</p><h2 id="符号表的表头" tabindex="-1"><a class="header-anchor" href="#符号表的表头" aria-hidden="true">#</a> 符号表的表头</h2><p>[<strong>等浏览完实验三要求再说</strong>]</p><ol><li><p>名字</p></li><li><p>类型(变量?结构体声明?数组?函数?) 【注意补充类型】</p></li><li><p>特性信息(根据类型来哩！)</p><blockquote><p>对于<strong>变量</strong>至少要记录<strong>变量名及其类型</strong></p><p>对于<strong>函数</strong>至少要记录其<strong>返回类型、参数个数以及参数类型</strong></p></blockquote></li><li><p>相对地址</p></li><li><p>[链表么]下一项的地址</p></li><li><p>...</p></li></ol><h2 id="什么时候填表" tabindex="-1"><a class="header-anchor" href="#什么时候填表" aria-hidden="true">#</a> 什么时候填表？</h2><blockquote><p>当<strong>分析到程序中的说明或定义语句</strong>时, 应将说明或定义的名字，以及与之有关的特性信息填入符号表中。</p></blockquote><p>而在<code>C--</code>文法中，<code>说明或定义语句</code>恰是<code>Def</code>和<code>ExtDef</code>，所以——</p><blockquote><p>当<strong>分析到<code>Def</code>和<code>ExtDef</code>时</strong>，就要填表</p></blockquote><p>更具体地说，是在声明全局变量、声明本地变量、声明结构体、声明结构体型的变量、声明函数的时候填表。</p><ul><li><p>声明全局变量</p><p><code>ExtDef → Specifier ExtDecList SEMI</code></p><p><code>ExtDecList → VarDec</code> --&gt;当这里导出来<code>VarDec</code>时，就可以知道变量名字和类型，就能填表了。 <code>ExtDecList → VarDec COMMA ExtDecList</code>--&gt;当这里导出来<code>VarDec</code>时，就可以知道变量名字和类型，就能填表了。</p><p><code>VarDec → ID</code>--&gt;这个能知道变量名字和基类型了！ <code>VarDec → VarDec LB INT RB</code>--&gt;这个出来之后，就能够构造数组类型了！需要把前一个VarDec的综合属性(基类型)</p></li><li><p>声明本地变量</p><p><code>CompSt → LC DefList StmtList RC</code></p><p><code>Def → Specifier DecList SEMI</code></p><p><code>DecList → Dec</code><code>DecList → Dec COMMA DecList</code><code>Dec → VarDec</code>--&gt;当这里导出来<code>VarDec</code>时，就可以知道变量名字和类型，就能填表了。 <code>Dec → VarDec ASSIGNOP Exp</code>--&gt;当这里导出来<code>VarDec</code>时，就可以知道变量名字和类型，就能填表了。</p><p><code>VarDec → ID</code>--&gt;这个能知道变量名字和基类型了！ <code>VarDec → VarDec LB INT RB</code>--&gt;这个出来之后，就能够构造数组类型了！需要把前一个VarDec的综合属性(基类型)</p></li><li><p>声明结构体</p><p><code>StructSpecifier → STRUCT OptTag LC DefList RC</code></p><p><code>DefList → Def DefList</code><code>DefList → 空</code></p><p><code>Def → Specifier DecList SEMI</code></p><p><code>DecList → Dec</code><code>DecList → Dec COMMA DecList</code><code>Dec → VarDec</code>--&gt;当这里导出来<code>VarDec</code>时，就可以知道变量名字和类型，就能填表了。 <code>Dec → VarDec ASSIGNOP Exp</code>--&gt;当这里导出来<code>VarDec</code>时，就可以知道变量名字和类型，就能填表了。</p><p><code>VarDec → ID</code>--&gt;这个能知道变量名字和基类型了！ <code>VarDec → VarDec LB INT RB</code>--&gt;这个出来之后，就能够构造数组类型了！需要把前一个VarDec的综合属性(基类型)</p></li><li><p>声明结构体型变量</p><p>同全局/局部变量</p></li><li><p>声明函数</p><p><code>ExtDef → Specifier FunDec CompSt</code>--<code>FunDec</code>出来后就能搞了</p><p><code>FunDec → ID LP VarList RP</code><code>FunDec → ID LP RP</code></p></li></ul><p>无论声明啥，都绕不过一个砍：<code>Specifier</code>，提供了基类型</p><p>无论声明啥，只有遇到了（树中最底层的）<code>VarDec</code>才能真·确定类型</p><h2 id="什么时候查表" tabindex="-1"><a class="header-anchor" href="#什么时候查表" aria-hidden="true">#</a> 什么时候查表？</h2><blockquote><p>正如实验1的难点在于和报错相关的<code>error</code>产生式书写，</p><p>实验2的难点在于什么时候进行查表(ww)</p></blockquote><ul><li><p><strong>填表前查表</strong></p><ul><li><p>在定义的时候--<strong>重复定义</strong>或声明结构体时<strong>结构体类型未定义</strong></p><blockquote><p>注：据假设4，所有变量的作用域都是全局的，即程序中声明的变量不能有重名的</p></blockquote><ul class="task-list-container"><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 错误类型3：<strong>变量</strong>出现<strong>重复定义</strong>，或<strong>变量</strong>与前面定义过的结构体名字重复</label></p><p>关键看<code>VarDec</code>和<code>Dec</code>，程序实现是在<code>Dec</code>插入表，故在插表前查表即可</p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> 错误类型4：函数出现<strong>重复定义</strong>（即同样的函数名出现了不止一次定义）</label></p><p><code>FunDec → ID LP VarList RP</code><code>FunDec → ID LP RP</code></p><p>关键看<code>FunDec</code>，因为设计的是完成<code>FunDec</code>后插表</p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 错误类型16：<strong>被定义</strong>结构体的名字与前面<strong>定义</strong>过的结构体或变量的名字<strong>重复</strong></label></p><p><code>StructSpecifier → STRUCT OptTag LC DefList RC</code></p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> 错误类型17：直接使用<strong>未定义</strong>过的<strong>结构体</strong>来<strong>定义变量</strong>。</label></p><p><code>StructSpecifier → STRUCT Tag</code></p><p>方案：查<code>Tag</code></p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 错误类型15：结构体中<strong>域名重复定义</strong>（指同一结构体中），或在<strong>定义时对域进行初始化</strong>（例如struct A { int a = 0; }）。</label></p><p>域名重复的检测采用“亡羊补牢”的策略，等到FieldList全部出来后，再使用双指针算法进行遍历，报错并去掉重复节点。</p><p><code>Dec → VarDec ASSIGNOP Exp</code>重复好说，初始化就看这个产生式啦！</p></li></ul></li><li><p>检查名字的种类是否与说明一致</p></li><li><p>检查表达式中各变量的类型是否一致</p></li></ul></li><li><p><strong>遇到<code>Exp</code>成分</strong></p><blockquote><p>每当遇到语法单元<code>Exp</code>，说明<strong>该结点及其子结点们</strong>会<strong>对变量或者函数进行使用</strong>，这个时候应当查符号表以确认<strong>这些变量或者函数是否存在以及它们的类型是什么</strong></p></blockquote><ul class="task-list-container"><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 错误类型1：变量在使用时<strong>未经定义</strong></label></p><p><code>Exp --&gt; ID</code></p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-6" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-6"> 错误类型2：函数在调用时<strong>未经定义</strong></label></p><p><code>Exp --&gt; ID LP Args RP</code></p><p><code>Exp --&gt; ID LP RP</code></p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-7" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-7"> 错误类型5：<strong>赋值号</strong>两边的<strong>表达式类型不匹配</strong>。</label></p><p><code>Exp → Exp ASSIGNOP Exp</code></p><p><code>Dec → VarDec ASSIGNOP Exp</code></p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-8" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-8"> 错误类型6：<strong>赋值号左边</strong>出现一个只有<strong>右值</strong>的表达式。</label></p><p><code>Exp → Exp ASSIGNOP Exp</code></p><p><code>Dec → VarDec ASSIGNOP Exp</code></p><p>方案：<strong>常数、表达式和函数调用</strong>一般只有右值而没有左值，反过来也就是只有<code>Exp LB Exp RB</code>、<code>Exp DOT ID</code>、<code>LP Exp RP</code>、<code>ID</code>行</p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-9" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-9"> 错误类型7：<strong>操作数类型不匹配</strong>或<strong>操作数类型与操作符</strong>不匹配（例如整型变量与数组变 量相加减，或数组（或结构体）变量与数组（或结构体）变量相加减）。</label></p><p><code>Exp → Exp AND Exp</code></p><p><code>Exp → Exp OR Exp</code></p><p><code>Exp → Exp RELOP Exp</code></p><p><code>Exp → Exp PLUS Exp</code></p><p><code>Exp → Exp MINUS Exp</code></p><p><code>Exp → Exp STAR Exp</code></p><p><code>Exp → Exp DIV Exp</code></p><p><code>Exp → MINUS Exp</code></p><p><code>Exp → NOT Exp</code></p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-10" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-10"> 错误类型8：return语句的<strong>返回类型</strong>与函数定义的返回类型<strong>不匹配</strong>。</label></p><p><code>Stmt → RETURN Exp SEMI</code></p><p>方案：得看当前<code>Stmt</code>所在的<code>CompSt</code>对应的函数的声明...(目前的想法是整一个临时变量来记录)</p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-11" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-11"> 错误类型9：函数<strong>调用时实参与形参</strong>的数目或类型不匹配。</label></p><p><code>Exp --&gt; ID LP Args RP</code> 对于这一条关注Args</p><p><code>Exp --&gt; ID LP RP</code></p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-12" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-12"> 错误类型10：对<strong>非数组型</strong>变量使用“[…]”（<strong>数组访问</strong>）操作符。</label></p><p><code>Exp → Exp LB Exp RB</code></p><p>方案：看<strong>右部第一个</strong><code>Exp</code>是不是数组类型</p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-13" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-13"> 错误类型11：对<strong>普通变量</strong>使用“(…)”或“()”（<strong>函数调用</strong>）操作符。</label></p><p><code>Exp --&gt; ID LP Args RP</code></p><p><code>Exp --&gt; ID LP RP</code></p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-14" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-14"> 错误类型12：<strong>数组访问</strong>操作符“[…]”中<strong>出现非整数</strong>（例如a[1.5]）。</label></p><p><code>Exp → Exp LB Exp RB</code></p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-15" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-15"> 错误类型13：对<strong>非结构体</strong>型变量<strong>使用“.”操作符</strong>。</label></p><p><code>Exp → Exp DOT ID</code></p><p>方案：看右部第一个<code>Exp</code>是不是结构体</p></li><li class="task-list-item"><p><input type="checkbox" class="task-list-item-checkbox" id="task-item-16" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-16"> 错误类型14：访问<strong>结构体中未定义过的域</strong>。</label></p><p><code>Exp → Exp DOT ID</code></p><p>方案：看右部第一个<code>Exp</code>的<code>Struct</code>的定义</p></li></ul></li><li><p><strong>生成目标代码时</strong>，需要查表以取得所需要的地址或者寄存器编号</p></li></ul><h1 id="细节" tabindex="-1"><a class="header-anchor" href="#细节" aria-hidden="true">#</a> 细节</h1><h2 id="deflist" tabindex="-1"><a class="header-anchor" href="#deflist" aria-hidden="true">#</a> DefList</h2><p>DefList会出现在三个地方</p><ol><li><code>StructSpecifier → STRUCT OptTag LC DefList RC</code></li><li><code>CompSt → LC DefList StmtList RC</code></li></ol><p>对于(1)，我们期望能够返回一个<code>FieldList</code>类型的综合属性，并且对于<code>DefList</code>中的每一个声明的变量，我们不把它加入符号表；</p><p>对于(2)，则没有必要返回<code>FieldList</code>类型的综合属性，但是要把<code>DefList</code>中的每一个声明出来的变量写入符号表。</p><h2 id="exp" tabindex="-1"><a class="header-anchor" href="#exp" aria-hidden="true">#</a> Exp</h2><p>Exp的类型，可以套用<code>Type</code>，但是还需要加一个：是不是右值。因为右值的判断方法和<code>Type</code>是不说话的。</p><blockquote><p>函数内的变量调用，要过一遍函数的参数list</p></blockquote>',32),d=[i];function l(a,p){return t(),c("div",null,d)}const n=e(o,[["render",l],["__file","lab2.html.vue"]]);export{n as default};
