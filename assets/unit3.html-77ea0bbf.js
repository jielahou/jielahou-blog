import{_ as e,W as d,X as c,$ as o}from"./framework-cb524fb0.js";const a={},n=o(`<blockquote><p>面向对象编程（OOP）的本质是<strong>设计并拓展自己的数据类型</strong>。设计自己的数据类型就是<strong>让类型与数据匹配</strong>。</p></blockquote><h1 id="简单变量" tabindex="-1"><a class="header-anchor" href="#简单变量" aria-hidden="true">#</a> 简单变量</h1><p>为了把数据存储到计算机中，需要记录3个属性——<strong>在哪里？啥类型？是什么？</strong></p><h2 id="变量名" tabindex="-1"><a class="header-anchor" href="#变量名" aria-hidden="true">#</a> 变量名</h2><p>变量名需遵循一定的规则，个人感觉下面这两条很新鲜：</p><ul><li>以<strong>两个下划线</strong>开头或者<strong>一个下划线+一个大写字母</strong>开头的名称被保留给实现（编译器及其使用的资源）使用</li><li>以<strong>一个下划线</strong>开头的名称被保留给实现，用作<strong>全局标识符</strong>。</li></ul><h2 id="整型" tabindex="-1"><a class="header-anchor" href="#整型" aria-hidden="true">#</a> 整型</h2><p>C++中有5种整型变量：<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>long long</code>（C++11新增），每种均有有符号和无符号版本。</p><h2 id="short、int、long和long-long" tabindex="-1"><a class="header-anchor" href="#short、int、long和long-long" aria-hidden="true">#</a> short、int、long和long long</h2><h3 id="宽度" tabindex="-1"><a class="header-anchor" href="#宽度" aria-hidden="true">#</a> 宽度</h3><p>4种类型的宽度在不同的计算机上可能不一样，但遵循如下的规则：</p><ul><li><code>short</code>至少为16位</li><li><code>int</code>至少和<code>short</code>一样</li><li><code>long</code>至少为32位，且至少和<code>int</code>一样</li><li><code>long long</code>至少为64位，且至少和<code>long</code>一样</li></ul><h3 id="sizeof和climits" tabindex="-1"><a class="header-anchor" href="#sizeof和climits" aria-hidden="true">#</a> <code>sizeof</code>和<code>climits</code></h3><p>我们可以使用<code>sizeof</code>运算符查看各类型在具体机器上的长度，使用<code>climits</code>头文件查看各类型可表示数值的范围（最大值、最小值）。</p><p><code>sizeof</code>可以作用于类型，也可以作用于变量名。<strong>作用于类型时，必须要加括号；作用于变量名时，可以不加括号。</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int x;
cout &lt;&lt; &quot;Size of int:&quot; &lt;&lt; sizeof x &lt;&lt; endl;//valid，不用加括号
cout &lt;&lt; &quot;Size of int:&quot; &lt;&lt; sizeof(int) &lt;&lt; endl;//valid，必须加括号
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="变量的初始化" tabindex="-1"><a class="header-anchor" href="#变量的初始化" aria-hidden="true">#</a> 变量的初始化</h3><h4 id="常规初始化" tabindex="-1"><a class="header-anchor" href="#常规初始化" aria-hidden="true">#</a> 常规初始化</h4><p>虽然可以先声明再赋值，但是如果知道变量的值是什么，应当<strong>在声明时立即对其进行初始化</strong>。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int uncles = 5;
int aunts = uncles;
int chairs = uncles + aunts;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="大括号初始化器" tabindex="-1"><a class="header-anchor" href="#大括号初始化器" aria-hidden="true">#</a> 大括号初始化器</h4><p>我们还可以使用<strong>大括号初始化器</strong>对<strong>数组和结构</strong>进行初始化。C++98允许我们用其对<strong>单值变量</strong>进行初始化。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int hamburgers = {24};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在C++11中，甚至可以略掉等号和其中的数字。（如果略掉其中的数字，则被初始化为0）</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int emus{};
int emus = {};
int emus{7};
int emus = {7};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>以前，初始化类变量的方式不同于初始化常规结构的方式、初始化常规结构的方式不同于初始化简单变量的方式。但大括号初始化器是一种<strong>通用</strong>的初始化语法，使得初始化常规变量的方式和类变量的方式更像。</p></blockquote><h2 id="无符号类型" tabindex="-1"><a class="header-anchor" href="#无符号类型" aria-hidden="true">#</a> 无符号类型</h2><p><code>unsigned</code>实际上是<code>unsigned int</code>的缩写。</p><h2 id="选择整数类型" tabindex="-1"><a class="header-anchor" href="#选择整数类型" aria-hidden="true">#</a> 选择整数类型</h2><ul><li>不知道该选啥就选<code>int</code></li><li>不可能为负就上<code>unsigned</code></li><li>如果大于32位，则选<code>long</code>（虽然某些机器上的<code>int</code>也是32位，但是不排除其他机器上的<code>int</code>是16位，如果此时仍然是<code>int</code>会出问题，用<code>long</code>不会出现这个问题。）</li><li>大型整型数组可以用<code>short</code>以节省内存空间</li></ul><h2 id="整型字面值" tabindex="-1"><a class="header-anchor" href="#整型字面值" aria-hidden="true">#</a> 整型字面值</h2><p><strong>整型字面值</strong>是显式地书写的常量。</p><p>C++中使用前1~2位标识常量的基数。</p><ul><li>十进制：第一位是1~9</li><li>八进制：第一位是0，第二位是1~7</li><li>十六进制：开头是<code>0x</code>或者<code>0X</code></li></ul><p>在C语言中，通过控制<code>printf</code>的格式串，我们可以指定是以十进制、八进制还是十六进制 显示整数。在C++中，我们可以使用控制符<code>dec</code>、<code>oct</code>、<code>hex</code>来指示<code>cout</code>以什么格式显式整数。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int x = 42;
int y = 042;
int z = 0x42;
cout &lt;&lt; dec &lt;&lt; x &lt;&lt; endl;//42
cout &lt;&lt; oct &lt;&lt; y &lt;&lt; endl;//42
cout &lt;&lt; hex &lt;&lt; z &lt;&lt; endl;//42
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="c-如何确定常量的类型" tabindex="-1"><a class="header-anchor" href="#c-如何确定常量的类型" aria-hidden="true">#</a> C++如何确定常量的类型</h2><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>cout &lt;&lt; &quot;Year:&quot; &lt;&lt; 1949 &lt;&lt; endl;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码片段中<code>1949</code>这个常量，会被存储为什么类型呢？</p><p>C++会将<strong>整型常量存储为<code>int</code>类型</strong>，除非是有<strong>特殊后缀</strong>、<strong>值太大不能存为<code>int</code></strong>。</p><h3 id="特殊后缀" tabindex="-1"><a class="header-anchor" href="#特殊后缀" aria-hidden="true">#</a> 特殊后缀</h3><p>后缀是放在数字常量后面的字母，用于表示类型。</p><ul><li><code>u</code>或<code>U</code>表示无符号常量</li><li><code>l</code>或<code>L</code>表示<code>long</code>型常量</li><li><code>ll</code>或<code>LL</code>表示<code>long long</code>型常量</li><li><code>ull</code>、<code>uLL</code>、<code>Ull</code>、<code>ULL</code>表示<code>unsigned long long</code>型常量</li></ul><h3 id="范围限定" tabindex="-1"><a class="header-anchor" href="#范围限定" aria-hidden="true">#</a> 范围限定</h3><p>对于十进制数字，会根据其范围选择是<code>int</code>、<code>long</code>还是<code>long long</code></p><p>对于八进制或者十六进制数字，会根据其范围选择是<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code>、<code>unsigned long long</code>。</p><h2 id="char类型" tabindex="-1"><a class="header-anchor" href="#char类型" aria-hidden="true">#</a> char类型</h2><p><code>char</code>类型实际上是另一种整型。C++中也有宽字符类型（譬如<code>wchar_t</code>）可以存储更多的值。</p><p>C++中的字符字面值是使用<code>&#39;</code>单引号包裹的，如<code>char x = &#39;x&#39;;</code>。</p><p><code>cout</code>输出<code>char</code>类型变量时，输出的是对应的字符；输出与<code>char</code>类型值一样的<code>int</code>类型变量时，输出的是数字。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>char x = &#39;x&#39;;
int y = x;
cout &lt;&lt; x &lt;&lt; endl;//x
cout &lt;&lt; y &lt;&lt; endl;//120
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>cin</code>读取输入流中的数字，如果赋给<code>char</code>类型，是将该数字对应的编码赋过去；如果赋给<code>int</code>类型，则是将数字直接赋过去。</p><h3 id="cout-put" tabindex="-1"><a class="header-anchor" href="#cout-put" aria-hidden="true">#</a> <code>cout.put()</code></h3><p>以前在C++的早期版本中，字符类型的常量被存储为<code>int</code>类型，故<code>cout &lt;&lt; &#39;x&#39;;</code>输出的会是数字，需借助<code>cout.put()</code>函数来输出字符类型的常量。现在是没有必要了。</p><h3 id="转义序列" tabindex="-1"><a class="header-anchor" href="#转义序列" aria-hidden="true">#</a> 转义序列</h3><p>转义序列允许我们表达无法用键盘输入的字符，如<code>\\n</code>、<code>\\b</code>（退格）等。</p><p>这些字符也是有其自己的编码的，故可以使用其八进制或十六进制编码来表示。比如<code>Ctrl + Z</code>在ASCII中的编码是<code>0x1a</code>，于是可用如下的转义序列表示：<code>\\032</code>、<code>\\x1a</code>。</p><blockquote><p>能使用符号转义序列，就不要使用其数字编码。因为不同机器不同编码对于同一个符号的编号可能不同，但符号转义序列是唯一的，会随着平台不同自动翻译。</p></blockquote><h3 id="通用字符名" tabindex="-1"><a class="header-anchor" href="#通用字符名" aria-hidden="true">#</a> 通用字符名</h3><p>通用字符名可以表示<code>ISO10646</code>中的码点，以<code>\\u</code>或<code>\\U</code>开头，<code>\\u</code>后面跟4个16进制位，<code>\\U</code>后面跟8个16进制位。</p><p><code>\\u798F</code>是<code>福</code>字的Unicode码点，其代表<code>福</code>字。不同机器上实际使用的编码可能会不同，故最终编译出来存储到程序中的编码可能会不同于其Unicode码点，但都是表示<code>福</code>字的码点。</p><p>之所以叫“通用字符名”，我们可以借助<code>ISO10646</code>来表示其中的任何一个字符，实际上最终的内部编码会是啥，由目标机器上的编译器做决定。</p><h3 id="signed-char和unsigned-char" tabindex="-1"><a class="header-anchor" href="#signed-char和unsigned-char" aria-hidden="true">#</a> signed char和unsigned char</h3><p><code>char</code>默认<strong>既不是</strong>有符号，<strong>也不是</strong>无符号，需要自己显式地指定。</p><h3 id="wchar-t" tabindex="-1"><a class="header-anchor" href="#wchar-t" aria-hidden="true">#</a> wchar_t</h3><p>我们可以用<code>wchar_t</code>（宽字符类型）来表示扩展字符集，其长度和符号属性取决于实现。</p><p>普普通通的<code>cin</code>和<code>cout</code>只能处理<code>char</code>流，好在<code>iostream</code>头文件提供了<code>wcin</code>、<code>wcout</code>来处理<code>wchar_t</code>流。</p><h3 id="char16-t和char32-t" tabindex="-1"><a class="header-anchor" href="#char16-t和char32-t" aria-hidden="true">#</a> char16_t和char32_t</h3><p>单有<code>wchar_t</code>已经不能满足需求，因为其具体长度会随实现不同而改变。C++11中新增了<code>char16_t</code>和<code>char32_t</code>。</p><p><code>char16_t</code>是16位无符号的，符号<strong>常量</strong>和字符串<strong>常量</strong>加前缀<code>u</code>便可表示其为<code>char16_t</code>类型的常量。</p><p><code>char32_t</code>是16位无符号的，符号<strong>常量</strong>和字符串<strong>常量</strong>加前缀<code>U</code>便可表示其为<code>char32_t</code>类型的常量。</p><h3 id="bool类型" tabindex="-1"><a class="header-anchor" href="#bool类型" aria-hidden="true">#</a> bool类型</h3><p><code>bool is_ready = true/false;</code></p><h2 id="const限定符" tabindex="-1"><a class="header-anchor" href="#const限定符" aria-hidden="true">#</a> const限定符</h2><p>在C++中，有比<code>#define</code>更好的表示常量的方法，那就是<code>const</code>限定符。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>const int x = 1;
x++;//error
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>const</code>而不是<code>#define</code>的好处如下：</p><ul><li><code>const</code>可以明确指明类型</li><li>可以根据作用域规则将定义限制于特定的函数/文件中，而不是全局</li></ul><h1 id="浮点数" tabindex="-1"><a class="header-anchor" href="#浮点数" aria-hidden="true">#</a> 浮点数</h1><h2 id="书写浮点数" tabindex="-1"><a class="header-anchor" href="#书写浮点数" aria-hidden="true">#</a> 书写浮点数</h2><ul><li>标准小数表示法，如<code>5.20</code></li><li>E表示法，如<code>9.11e-39</code></li></ul><h2 id="浮点类型" tabindex="-1"><a class="header-anchor" href="#浮点类型" aria-hidden="true">#</a> 浮点类型</h2><p>浮点有<code>float</code>、<code>double</code>、<code>long double</code>三种类型。</p><blockquote><p>使用<code>cout.setf()</code>可以设置输出格式。</p><p>如<code>cout.setf(ios_base::fixed, ios_base::floatfield)</code></p></blockquote><h2 id="浮点常量" tabindex="-1"><a class="header-anchor" href="#浮点常量" aria-hidden="true">#</a> 浮点常量</h2><p>浮点常量默认是<code>double</code>类型，如果期望有所更改，则可以添加后缀：</p><p>希望常量是<code>float</code>类型，可以添加<code>f</code>或<code>F</code>后缀；</p><p>希望常量是<code>long double</code>类型，可以添加<code>l</code>或<code>L</code>后缀。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>cout &lt;&lt; sizeof(1.0f) &lt;&lt; endl;//4
cout &lt;&lt; sizeof(1.0) &lt;&lt; endl;//8
cout &lt;&lt; sizeof(1.0L) &lt;&lt; endl;//16
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="浮点数的优缺点" tabindex="-1"><a class="header-anchor" href="#浮点数的优缺点" aria-hidden="true">#</a> 浮点数的优缺点</h2><p>优点：表示范围很大</p><p>缺点：运算慢、精度低</p><h1 id="c-算术运算符" tabindex="-1"><a class="header-anchor" href="#c-算术运算符" aria-hidden="true">#</a> C++算术运算符</h1><p>C++的算术运算符有：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>。</p><p>对于求余，如果有一个操作数是负的，<code>a%b</code>的结果遵循下式<code>(a/b)*b + a%b = a</code>。（如：<code>8%-3</code>的结果遵循<code>(8/-3)*(-3) + a%b = 8</code>，如此便得<code>a%b = 2</code>）</p><h2 id="运算符优先级和结合性" tabindex="-1"><a class="header-anchor" href="#运算符优先级和结合性" aria-hidden="true">#</a> 运算符优先级和结合性</h2><p>先看优先级，再看结合性。</p><p>所谓结合性，处理的是当两个符号<strong>优先级相同</strong>，且<strong>作用于同一个操作数</strong>时，这个操作数首先会被谁作用的问题。如<code>120 / 4 * 5 </code>，这个<code>4</code>先跟谁算呢？是先算<code>120 / 4</code>（得到<code>30</code>，然后<code>30 * 5</code>，得到结果<code>150</code>），还是先算<code>4 * 5</code>呢（得到<code>20</code>，然后<code>120 / 20</code>，得到结果<code>6</code>）？</p><p>由于乘除都是“从左到右结合”的，所以先算<code>120 / 4</code>，再算<code>30 * 5</code>。</p><h2 id="除法分支" tabindex="-1"><a class="header-anchor" href="#除法分支" aria-hidden="true">#</a> 除法分支</h2><p>对不同类型的数字进行运算时，会转换成同一类型的进行计算。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>cout.setf(ios_base::fixed, ios_base::floatfield);
cout &lt;&lt; 1e7 / 9.0 &lt;&lt; endl;//1111111.111111
cout &lt;&lt; 1e7f / 9.0f &lt;&lt;endl;//1111111.125000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上例中，由于第二行均为<code>double</code>类型，第三行均为<code>float</code>类型，故第二行结果也是<code>double</code>的，精度更高；第三行结果是<code>float</code>的，精度稍次。</p><h2 id="类型转换" tabindex="-1"><a class="header-anchor" href="#类型转换" aria-hidden="true">#</a> 类型转换</h2><p>下面主要介绍三种情况下涉及到的自动的类型转换</p><ul><li>将一种算术类型的值赋给另一种算术类型的变量（初始化）</li><li>表达式中包含不同的类型</li><li>参数传递给函数</li></ul><h3 id="初始化和赋值进行的转换" tabindex="-1"><a class="header-anchor" href="#初始化和赋值进行的转换" aria-hidden="true">#</a> 初始化和赋值进行的转换</h3><p>如果将一种类型的值赋给另一种类型的变量，那么<strong>值将会转换成接受变量的类型</strong>。</p><p>转换时可能有精度、溢出的问题。</p><p>将<strong>浮点型转换为整型</strong>时，C++采取<strong>截取</strong>（丢掉小数部分）而不是四舍五入。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int x = 4.9;//Warning
cout &lt;&lt; x &lt;&lt; endl;//4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<strong>大括号</strong>进行初始化时，其<strong>不允许缩窄</strong>，即不允许被赋值的变量表示不了赋予的值。譬如整型不能表示浮点型、<code>char</code>只能表示<code>-128~127</code>间的数字等。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>char x = {999};//Constant expression evaluates to 999 which cannot be narrowed to type &#39;char&#39;
int y = {8.9};//Type &#39;double&#39; cannot be narrowed to &#39;int&#39; in initializer list
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>用大括号进行初始化时，还不能包含变量，因为编译器无法预知变量的值是否满足缩窄。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int x = 99;
char y = {x};//Non-constant-expression cannot be narrowed from type &#39;int&#39; to &#39;char&#39; in initializer list
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="表达式中的转换" tabindex="-1"><a class="header-anchor" href="#表达式中的转换" aria-hidden="true">#</a> 表达式中的转换</h3><p>表达式中的转换又分为两种，一种是一出现就会被转换的，另一种是和其他类型同时出现时才转换。</p><h4 id="一出现就被转换-整型提升" tabindex="-1"><a class="header-anchor" href="#一出现就被转换-整型提升" aria-hidden="true">#</a> 一出现就被转换（整型提升）</h4><p>C++在计算表达式时，将<code>bool</code>、<code>char</code>、<code>unsigned char</code>、<code>signed char</code>、<code>short</code>值转换为<code>int</code>。</p><p>除此，如果<code>short</code>比<code>int</code>短，那么<code>unsigned short</code>转换为<code>int</code>；如果<code>short</code>和<code>int</code>一样长，那么<code>unsigned short</code>转换为<code>unsigned int</code>。</p><p><code>wchar_t</code>也会被转换为第一个能够满足需求的类型：<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>。</p><h3 id="不同类型算术运算的转换" tabindex="-1"><a class="header-anchor" href="#不同类型算术运算的转换" aria-hidden="true">#</a> 不同类型算术运算的转换</h3><p>较小的类型会转换为较大的类型。如<code>int</code>和<code>float</code>相加，<code>int</code>会被转换成<code>float</code>。</p><h3 id="传递参数时的转换" tabindex="-1"><a class="header-anchor" href="#传递参数时的转换" aria-hidden="true">#</a> 传递参数时的转换</h3><p>由函数原型控制。不控制的，<code>char</code>和<code>short</code>做整型提升，<code>float</code>提成<code>double</code>。</p><h3 id="强制类型转换" tabindex="-1"><a class="header-anchor" href="#强制类型转换" aria-hidden="true">#</a> 强制类型转换</h3><p>强制类型转换的格式如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>(int) x;//(typeName) value
int (x);//typeName (value)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除此，还有4个强制类型转换运算符，<code>static_cast&lt;&gt;</code>就是其中之一。<code>static_cast&lt;&gt;</code>相较于传统强转，其实是更严格的。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>short x = 5;
cout &lt;&lt; static_cast&lt;int&gt;(x)&lt;&lt; endl;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="auto声明" tabindex="-1"><a class="header-anchor" href="#auto声明" aria-hidden="true">#</a> <code>auto</code>声明</h3><p>如果使用关键字<code>auto</code>声明变量，那么编译器会把变量的<strong>类型</strong>设置成<strong>与初始值相同</strong>。</p><p><code>auto</code>在处理复杂类型时，优势方才显现。</p>`,133),i=[n];function r(t,l){return d(),c("div",null,i)}const h=e(a,[["render",r],["__file","unit3.html.vue"]]);export{h as default};
