import{_ as e,W as d,X as a,$ as n}from"./framework-33bc0f2f.js";const i={},c=n(`<h1 id="指针与c-基本原理" tabindex="-1"><a class="header-anchor" href="#指针与c-基本原理" aria-hidden="true">#</a> 指针与C++基本原理</h1><p>面向对象编程和传统的过程性编程的区别在于，OOP强调在运行阶段（而不是编译阶段）进行决策。</p><p>起初要使用数组，就必须要写死元素个数。但是OOP中可以通过关键字<code>new</code>和<code>delete</code>在运行时动态分配内存。虽然C也可以使用<code>malloc</code>和<code>free</code>实现类似效果，但是C++会更易用一些。</p><p>常规变量使用<code>&amp;</code>来获取地址，指针变量用<code>*</code>来获取该地址存储的值。</p><h2 id="声明和初始化指针" tabindex="-1"><a class="header-anchor" href="#声明和初始化指针" aria-hidden="true">#</a> 声明和初始化指针</h2><p>对于下面的声明，<code>x1</code>是<code>int</code>类型的指针，但是<code>x2</code>不是指针哟！</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int* x1, x2;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果想让<code>x2</code>也是指针，应该这么玩：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int *x1, *x2;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里注意到了，<code>*</code>的前后都可以加（去）空格，所以也可以：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int*x1,*x2;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="指针的危险" tabindex="-1"><a class="header-anchor" href="#指针的危险" aria-hidden="true">#</a> 指针的危险</h2><p>在对一个指针解引用<code>*</code>之前，一定要记得<strong>将指针初始化</strong>啊！</p><h2 id="指针和数字" tabindex="-1"><a class="header-anchor" href="#指针和数字" aria-hidden="true">#</a> 指针和数字</h2><p>指针和数字是截然不同的两个类型，虽然指针本质是记录存储位置的数。譬如数字可以加减乘除，但是指针的乘除没有意义。</p><p>C++对于类型一致的要求更为严格，所以我们<strong>不能直接把一个数字赋给一个指针</strong>。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int* x1;
x1 = 0xB8000000;//invalid, Incompatible integer to pointer conversion assigning to &#39;int *&#39; from &#39;unsigned int&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>真想赋，那就得类型转换：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int* x1;
x1 = (int*)0xB8000000;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="使用new来分配内存" tabindex="-1"><a class="header-anchor" href="#使用new来分配内存" aria-hidden="true">#</a> 使用<code>new</code>来分配内存</h2><p>指针的最大用途是：在<strong>运行时</strong>分配未命名的内存来存储值。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>typeName * pointer_name = new typeName;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>值得一提的是，在C语言中，我们使用<code>malloc</code>和<code>free</code>进行分配和释放内存。那么在C++中，虽然<code>malloc</code>和<code>free</code>还可以再接着用，但是用的时候一定要注意“配对”，<code>malloc</code>来的，一定要用<code>free</code>解决掉。</p><p>对于“配对”的问题，如果使用<code>new</code>创建数组（则意味着有<code>[]</code>），那么<code>delete</code>的时候也一定要加上<code>[]</code>。</p></blockquote><p><strong>变量</strong>从<strong>栈</strong>中分配内存块，<strong><code>new</code><strong>从</strong>堆</strong>中分配内存块。</p><h2 id="使用delete来删除内存" tabindex="-1"><a class="header-anchor" href="#使用delete来删除内存" aria-hidden="true">#</a> 使用<code>delete</code>来删除内存</h2><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int * ps = new int;
delete ps;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>只能用<code>delete</code>删除由<code>new</code>获得的指针地址</li><li><code>delete</code>不能将一个地址释放两次，否则结果不确定</li><li>对于空指针，使用<code>delete</code>是安全的</li></ul><h2 id="使用new来创建动态数组" tabindex="-1"><a class="header-anchor" href="#使用new来创建动态数组" aria-hidden="true">#</a> 使用<code>new</code>来创建动态数组</h2><h3 id="创建动态数组" tabindex="-1"><a class="header-anchor" href="#创建动态数组" aria-hidden="true">#</a> 创建动态数组</h3><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>typeName * pointer_name = new type_name [num_elements];
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对应的使用<code>delete</code>释放内存时，也要带上<code>[]</code>。方括号告诉<code>delete</code>，释放的是整个数组，而不仅仅是指向数组的元素。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>delete [] pointer_name;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="使用动态数组" tabindex="-1"><a class="header-anchor" href="#使用动态数组" aria-hidden="true">#</a> 使用动态数组</h3><p>我们可以像使用普通数组那样使用动态数组。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int * array = new int [10];
array[0] = ...;
array[1] = ...;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>普通数组名和指针的区别在于，指针是个变量，可以做加减法、被修改。数组名不能被修改。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>array = array + 1;//valid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一个有趣的问题：<code>array</code>加1后变成了什么？答案是：变成了<strong>下一个元素的地址</strong>，而不是纯粹的在原本的地址上加上1。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int *x1 = new int [100];
cout &lt;&lt; x1++ &lt;&lt; &quot; vs &quot; &lt;&lt; x1;
//0x562acce3eeb0 vs 0x562acce3eeb4
//@jielahou
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="指针、数组和指针算术" tabindex="-1"><a class="header-anchor" href="#指针、数组和指针算术" aria-hidden="true">#</a> 指针、数组和指针算术</h1><blockquote><p>上面只是简单的开了个头，介绍了下指针和数组名的关系，下面接着探讨。</p></blockquote><h2 id="指针和数组名的联系" tabindex="-1"><a class="header-anchor" href="#指针和数组名的联系" aria-hidden="true">#</a> 指针和数组名的联系</h2><p>C++中，大多数情况下将<strong>数组名</strong>解释为数组中<strong>第一个元素的地址</strong>，即：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>double wages[3] = {2.0};
//于是下面的等式成立
wages == &amp;wages[0];
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>既然数组名是地址，所以<strong>下面两种表示法</strong>（数组表示法、指针表示法）<strong>是等价的</strong>。（事实上，C++会对数组表示法转换成指针表示法。）</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>arrayName[1] ==&gt; *(arrayName + 1)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="指针和数组名的区别" tabindex="-1"><a class="header-anchor" href="#指针和数组名的区别" aria-hidden="true">#</a> 指针和数组名的区别</h2><p>前面提到：</p><ul><li><strong>指针变量加1</strong>后，增加的量等于它<strong>指向类型的字节数</strong></li><li>数组名的区别之一在于<strong>数组名是常量</strong>，而<strong>指针是变量</strong></li></ul><p>第二个区别在于：对数组名使用<code>sizeof</code>，得到的是整个数组占得空间；对指针使用<code>sizeof</code>，得到的是指针占的空间。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int *x1 = new int [20];
int x2[20];
cout &lt;&lt; sizeof x1 &lt;&lt; endl;//8
cout &lt;&lt; sizeof x2 &lt;&lt; endl;//80
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="数组名的地址" tabindex="-1"><a class="header-anchor" href="#数组名的地址" aria-hidden="true">#</a> 数组名的地址？</h2><p>如果<code>tell</code>是<strong>数组</strong>名，那么<code>&amp;tell</code>是什么东西？</p><p>从数值上看，两者的值是相等的。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int tell[20];
cout &lt;&lt; tell &lt;&lt; endl;//0x7ffca1cf7ea0
cout &lt;&lt; &amp;tell &lt;&lt; endl;//0x7ffca1cf7ea0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道，指针是有类型的。<code>&amp;tell</code>是<strong>指向“一整块”数组</strong>的指针。（回忆<code>tell</code>是指向第一个元素的指针）不信，加个1看看。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int tell[20];
cout &lt;&lt; &amp;tell &lt;&lt; endl;//0x7ffd8ab62de0
cout &lt;&lt; (&amp;tell) + 1 &lt;&lt; endl;//0x7ffd8ab62e30
cout &lt;&lt; tell &lt;&lt; endl;//0x7ffd8ab62de0
cout &lt;&lt; tell + 1 &lt;&lt; endl;//0x7ffd8ab62de4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，<code>(&amp;tell) + 1</code>和<code>&amp;tell</code>正好差了80，即20个4字节<code>int</code>。而<code>tell + 1</code>和<code>tell</code>只差了4，即1个4字节<code>int</code>。</p><p>对于<code>int tell[20]</code>，<code>&amp;tell</code>的类型实际上为<code>int (*)[20]</code>。</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>int (*pointer)[20] = &amp;tell;//如果没有括号，pointer先和[20]结合，pointer实际上变成了存储20个(int *)类型的数组
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,60),l=[c];function s(r,t){return d(),a("div",null,l)}const u=e(i,[["render",s],["__file","unit4.5.html.vue"]]);export{u as default};
