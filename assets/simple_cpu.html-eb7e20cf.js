import{_ as e,W as c,X as t,$ as a,Y as s}from"./framework-33bc0f2f.js";const l={},n=a('<blockquote><p>本文实际上是对《CPU设计实战》（汪文祥 邢金璋 著）一书第四章的简单总结、概括。</p></blockquote><h1 id="设计一个简单的单周期cpu" tabindex="-1"><a class="header-anchor" href="#设计一个简单的单周期cpu" aria-hidden="true">#</a> 设计一个简单的单周期CPU</h1><blockquote><p>CPU设计的一般方法：数据通路+控制逻辑</p></blockquote><h2 id="准备工作" tabindex="-1"><a class="header-anchor" href="#准备工作" aria-hidden="true">#</a> 准备工作</h2><h3 id="如何划分模块" tabindex="-1"><a class="header-anchor" href="#如何划分模块" aria-hidden="true">#</a> 如何划分模块</h3><ul><li>某层次设计细节很多，很难画出来，把他干成一个框，作为一个模块</li><li>模块的接口不应该有太多</li><li>可以被多次使用的，比如译码器、多路选择器、寄存器堆、RAM、FIFO（First In First Out）</li><li>两个模块间数据总体应该呈单向流动，至多一去一回。</li></ul><h3 id="pc" tabindex="-1"><a class="header-anchor" href="#pc" aria-hidden="true">#</a> PC</h3><p>PC的输入有两个：一个是复位值<code>0xBFC00000</code>，一个是复位撤销后每执行一条指令，当前<code>PC+4</code>的结果。</p><h3 id="虚实地址转换" tabindex="-1"><a class="header-anchor" href="#虚实地址转换" aria-hidden="true">#</a> 虚实地址转换</h3><p>在实现TLB和MMU之前，我们采用<strong>固定映射</strong>的地址映射机制。</p><p><code>kseg0</code>（<code>0x80000000</code><sub>`0x9FFFFFFF`）映射到物理地址最低512M（`0x00000000`</sub><code>0x1FFFFFFF</code>）；</p><p><code>kseg1</code>（<code>0xA0000000</code><sub>`0xBFFFFFFF`）也映射到物理地址最低512M（`0x00000000`</sub><code>0x1FFFFFFF</code>）；</p><p>其余三个段（<code>kuseg</code>、<code>kseg2</code>、<code>kseg3</code>）虚地址等于物理地址。</p><h3 id="指令ram" tabindex="-1"><a class="header-anchor" href="#指令ram" aria-hidden="true">#</a> 指令RAM</h3><p>由于欲实现的CPU指令宽度为32比特，所以RAM的宽度至少为32比特。但RAM还是按照字节寻址的，所以我们要将取指地址除4后取整的结果作为RAM的地址输入。</p><h2 id="数据通路设计" tabindex="-1"><a class="header-anchor" href="#数据通路设计" aria-hidden="true">#</a> 数据通路设计</h2><h3 id="addu指令" tabindex="-1"><a class="header-anchor" href="#addu指令" aria-hidden="true">#</a> ADDU指令</h3><p>通用寄存器堆的读端口1和读端口2分别和<code>rs</code>、<code>rt</code>相连；</p><p>要实现加法，需要一个加法器。加法器两个输入<code>src1</code>、<code>src2</code>分别来自通用寄存器堆的<code>rdata1</code>、<code>rdata2</code>，输出<code>result</code>连接通用寄存器堆的<code>wdata</code>。</p><h3 id="addiu指令" tabindex="-1"><a class="header-anchor" href="#addiu指令" aria-hidden="true">#</a> ADDIU指令</h3><blockquote><p>ADDIU和ADDU指令很像，如何兼顾差异性，又能最大限度复用呢？</p></blockquote><p>从差异性入手，ADDIU和ADDU指令区别于ADDIU第二个操作数来自于指令的<code>15..0</code>位符号拓展至32位后形成的数据。所以在加法器<code>src2</code>输入端口前面加一个<strong>二选一</strong>部件。<code>in0</code>来自于通用寄存器堆的<code>rdata2</code>，<code>in1</code>来自指令的<code>15..0</code>位符号拓展至32位后形成的数据。控制信号的生成（包括接下来若干条指令的控制信号）统一放到最后说。</p><p>另一个区别，ADDU写入第<code>rd</code>号寄存器，ADDIU写入第<code>rt</code>号寄存器。在通用寄存器堆前面也加一个二选一部件，<code>in0</code>来自<code>rd</code>，<code>in1</code>来自<code>rt</code>。</p><h3 id="subu指令" tabindex="-1"><a class="header-anchor" href="#subu指令" aria-hidden="true">#</a> SUBU指令</h3><p>复用加法器来实现减法，处理方法如下：</p>',25),d=s("p",{class:"katex-block"},[s("span",{class:"katex-display"},[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"},[s("semantics",null,[s("mrow",null,[s("mo",{stretchy:"false"},"["),s("mi",null,"A"),s("msub",null,[s("mo",{stretchy:"false"},"]"),s("mrow",null,[s("mtext",null,"原码"),s("mn",null,"31..0")])]),s("mo",null,"−"),s("mo",{stretchy:"false"},"["),s("mi",null,"B"),s("msub",null,[s("mo",{stretchy:"false"},"]"),s("mrow",null,[s("mtext",null,"原码"),s("mn",null,"31..0")])]),s("mo",null,"="),s("mo",{stretchy:"false"},"["),s("mi",null,"A"),s("msub",null,[s("mo",{stretchy:"false"},"]"),s("mrow",null,[s("mtext",null,"原码"),s("mn",null,"31..0")])]),s("mo",null,"+"),s("mo",{stretchy:"false"},"("),s("mstyle",{mathcolor:"#cc0000"},[s("mtext",null,"\\textasciitilde")]),s("mo",{stretchy:"false"},"["),s("mi",null,"B"),s("msub",null,[s("mo",{stretchy:"false"},"]"),s("mrow",null,[s("mtext",null,"原码"),s("mn",null,"31..0")])]),s("mo",{stretchy:"false"},")"),s("mo",null,"+"),s("mn",null,"1")]),s("annotation",{encoding:"application/x-tex"}," [A]_{原码31..0}-[B]_{原码31..0}=[A]_{原码31..0}+(\\textasciitilde[B]_{原码31..0})+1 ")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mclose"},[s("span",{class:"mclose"},"]"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3283em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord cjk_fallback mtight"},"原码"),s("span",{class:"mord mtight"},"31..0")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05017em"}},"B"),s("span",{class:"mclose"},[s("span",{class:"mclose"},"]"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3283em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord cjk_fallback mtight"},"原码"),s("span",{class:"mord mtight"},"31..0")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal"},"A"),s("span",{class:"mclose"},[s("span",{class:"mclose"},"]"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3283em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord cjk_fallback mtight"},"原码"),s("span",{class:"mord mtight"},"31..0")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord text",style:{color:"#cc0000"}},[s("span",{class:"mord",style:{color:"#cc0000"}},"\\textasciitilde")]),s("span",{class:"mopen"},"["),s("span",{class:"mord mathnormal",style:{"margin-right":"0.05017em"}},"B"),s("span",{class:"mclose"},[s("span",{class:"mclose"},"]"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t vlist-t2"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.3283em"}},[s("span",{style:{top:"-2.55em","margin-left":"0em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mtight"},[s("span",{class:"mord cjk_fallback mtight"},"原码"),s("span",{class:"mord mtight"},"31..0")])])])]),s("span",{class:"vlist-s"},"​")]),s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.15em"}},[s("span")])])])])]),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"+"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6444em"}}),s("span",{class:"mord"},"1")])])])])],-1),o=a('<p>其中<code>~</code>是按位取反，上式中即为对<code>[B]原码</code>的32位取反。</p><p>于是需要在加法器的<code>src2</code>前面再加一个二选一部件：处理加法时不取反，直接进来；处理减法时先取反，再进来。</p><p>后面还有一个<code>+</code>，可以通过<strong>操作加法器进位输入</strong>实现。处理加法进位输入是0，操作减法进位输入是1。</p><h3 id="lw指令" tabindex="-1"><a class="header-anchor" href="#lw指令" aria-hidden="true">#</a> LW指令</h3><h4 id="访存地址生成" tabindex="-1"><a class="header-anchor" href="#访存地址生成" aria-hidden="true">#</a> 访存地址生成</h4><p>要求是将<code>rs</code>和指令中的立即数相加，和<code>ADDIU</code>一致。</p><h4 id="从数据ram中读数据" tabindex="-1"><a class="header-anchor" href="#从数据ram中读数据" aria-hidden="true">#</a> 从数据RAM中读数据</h4><p>根据指令系统规范文档中对<code>LW</code>指令的描述，<code>LW</code>一次性要读4个字节写入第<code>rt</code>号寄存器。所以数据RAM宽度也应该是32位，因此<code>LW</code>指令的访存地址应该是4的倍数。</p><h4 id="寄存器写回结果选择" tabindex="-1"><a class="header-anchor" href="#寄存器写回结果选择" aria-hidden="true">#</a> 寄存器写回结果选择</h4><p>之前我们只有<code>ADDU</code>、<code>ADDIU</code>两条指令写寄存器，那俩都是将加法器的结果接到通用寄存器堆的<code>wdata</code>上，写入寄存器。现在又多一个<code>LW</code>，那只能在寄存器堆<code>wdata</code>前面再加一个二选一部件。</p><h3 id="sw指令" tabindex="-1"><a class="header-anchor" href="#sw指令" aria-hidden="true">#</a> SW指令</h3><p><code>SW</code>指令将<code>rt</code>寄存器的内容写入数据RAM，因此我们将通用寄存器堆的<code>rdata2</code>和数据RAM的<code>wdata</code>相连，将数据RAM的写使能作为控制信号。</p><h3 id="beq和bne指令" tabindex="-1"><a class="header-anchor" href="#beq和bne指令" aria-hidden="true">#</a> BEQ和BNE指令</h3><h4 id="判断分支条件" tabindex="-1"><a class="header-anchor" href="#判断分支条件" aria-hidden="true">#</a> 判断分支条件</h4><p>要比较两个寄存器中的数字，一种方法是复用加法器，做减法，看结果；另一种方法是设置<strong>独立的分支判断逻辑</strong>。</p><h4 id="计算跳转目标" tabindex="-1"><a class="header-anchor" href="#计算跳转目标" aria-hidden="true">#</a> 计算跳转目标</h4><p>MIPS中有“延迟槽”的概念，由于判断分支条件会浪费一些时间，于是便可以把<strong>不管是不是跳转一定要执行的指令</strong>放在<strong>条件分支指令</strong>（注意是条件分支）的后面，在判断分支条件时并行执行，提高效率。</p><p>这意味着如果有一个PC为A的指令，使用分支跳转指令如果成功跳到B的话，其执行轨迹实际上是A、A+4、B。所以<strong>执行分支指令后面的延迟槽指令时</strong>才是<strong>真正调整PC的时机</strong>。</p><p>故<code>BEQ</code>和<code>BNE</code>计算跳转目标时是<strong>基于延迟槽指令的PC</strong>再加上(<code>offset</code>左移两位的结果)得到的。</p><h4 id="pc更新" tabindex="-1"><a class="header-anchor" href="#pc更新" aria-hidden="true">#</a> PC更新</h4><p>由于是在下一条延迟槽指令进行PC更新，所以我们需要将加法器（毕竟复用了<code>ADDIU</code>的数据通路么）的输出放入一个触发器中。</p><p>既然引入了分支跳转指令，<code>nextPC</code>的来源不只是当前指令PC+4了。我们要给<code>nextPC</code>加一个二选一部件，<code>in0</code>来自PC+4，另一个输入<code>in1</code>来自触发器。</p><p>什么时候选择触发器中的数据呢？条件有二：一是当前<strong>正在执行延迟槽中的指令</strong>，二是<code>BEQ</code>、<code>BNE</code><strong>要求跳转</strong>。</p><h3 id="jal指令" tabindex="-1"><a class="header-anchor" href="#jal指令" aria-hidden="true">#</a> JAL指令</h3>',24),r=[n,d,o];function i(h,p){return c(),t("div",null,r)}const g=e(l,[["render",i],["__file","simple_cpu.html.vue"]]);export{g as default};
